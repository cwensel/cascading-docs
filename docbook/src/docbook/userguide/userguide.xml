<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2007-2012 Concurrent, Inc. All Rights Reserved.
  ~
  ~ Project and contact information: http://www.concurrentinc.com/
  -->
<book version="5.0" xml:lang="en" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
  >
  <info>
    <title>Cascading 2.1 User Guide</title>

    <releaseinfo/>

    <pubdate>September 2012</pubdate>

    <copyright>
      <year>2007-2012</year>

      <holder>Concurrent, Inc.</holder>
    </copyright>

    <productname>Cascading</productname>

    <authorgroup>
      <author>
        <personname>Concurrent, Inc.</personname>
      </author>
    </authorgroup>

    <mediaobject>
      <imageobject role="fo">
        <imagedata contentwidth="2in" fileref="images/cascading-logo.svg"/>
      </imageobject>

      <imageobject role="html">
        <imagedata contentwidth="2in" fileref="images/cascading-logo.png"/>
      </imageobject>
    </mediaobject>
  </info>

  <toc/>

  <chapter>
    <info>
      <title>About Cascading</title>
    </info>

    <section>
      <title>What is Cascading?</title>

      <para>Cascading is a data processing API and processing query planner
        used for defining, sharing, and executing data-processing workflows on a
        single computing node or distributed computing cluster. On a single
        node, Cascading's "local mode" can be used to efficiently test code and
        process local files before being deployed on a cluster. On a distributed
        computing cluster using Apache Hadoop platform, Cascading adds an
        abstraction layer over the Hadoop API, greatly simplifying Hadoop
        application development, job creation, and job scheduling.
      </para>
    </section>

    <section>
      <title>Usage Scenarios</title>

      <section>
        <title>Why use Cascading?</title>

        <para>Cascading was developed to allow organizations to rapidly
          develop complex data processing applications with Hadoop. The need for
          Cascading is typically driven by one of two cases:
        </para>

        <para>
          <emphasis role="bold">Increasing data size</emphasis>
          exceeds
          the processing capacity of a single computing system. In response,
          developers may adopt Apache Hadoop as the base computing
          infrastructure, but discover that developing useful applications on
          Hadoop is not trivial. Cascading eases the burden on these developers
          and allows them to rapidly create, refactor, test, and execute complex
          applications that scale linearly across a cluster of computers.
        </para>

        <para>
          <emphasis role="bold">Increasing process complexity in data
            centers
          </emphasis>
          results in one-off data-processing applications
          sprawling haphazardly onto any available disk space or CPU. Apache
          Hadoop solves the problem with its Global Namespace file system, which
          provides a single reliable storage framework. In this scenario,
          Cascading eases the learning curve for developers as they convert
          their existing applications for execution on a Hadoop cluster for its
          reliability and scalability. In addition, it lets developers create
          reusable libraries and applications for use by analysts, who use them
          to extract data from the Hadoop file system.
        </para>

        <para>Since Cascading's creation, a number of Domain Specific
          Languages (DSLs) have emerged as query languages that wrap the
          Cascading APIs, allowing developers and analysts to create ad-hoc
          queries for data mining and exploration. These DSLs coupled with
          Cascading local-mode allow users to rapidly query and analyze
          reasonably large datasets on their local systems before executing them
          at scale in a production environment. See the section on DSLs for
          references.
        </para>
      </section>

      <section>
        <title>Who are the users?</title>

        <para>Cascading users typically fall into three roles:</para>

        <para>
          <emphasis role="bold">The application Executor</emphasis>
          is a
          person (e.g., a developer or analyst) or process (e.g., a cron job)
          that runs a data processing application on a given cluster. This is
          typically done via the command line, using a pre-packaged Java Jar
          file compiled against the Apache Hadoop and Cascading libraries. The
          application may accept command-line parameters to customize it for a
          given execution, and generally outputs a data set to be exported from
          the Hadoop file system for some specific purpose.
        </para>

        <para>
          <emphasis role="bold">The process Assembler</emphasis>
          is a
          person who assembles data processing workflows into unique
          applications. This work is generally a development task that involves
          chaining together operations to act on one or more input data sets,
          producing one or more output data sets. This can be done with the raw
          Java Cascading API, or with a scripting language such as Scale,
          Clojure, Groovy, JRuby, or Jython (or by one of the DSLs implemented
          in these languages).
        </para>

        <para>
          <emphasis role="bold">The operation Developer</emphasis>
          is a
          person who writes individual functions or operations (typically in
          Java) or reusable subassemblies that act on the data that passes
          through the data processing workflow. A simple example would be a
          parser that takes a string and converts it to an Integer. Operations
          are equivalent to Java functions in the sense that they take input
          arguments and return data. And they can execute at any granularity,
          from simply parsing a string to performing complex procedures on the
          argument data using third-party libraries.
        </para>

        <para>All three roles can be filled by a developer, but because
          Cascading supports a clean separation of these responsibilities, some
          organizations may choose to use non-developers to run ad-hoc
          applications or build production processes on a Hadoop cluster.
        </para>
      </section>
    </section>

    <section>
      <title>What is Apache Hadoop?</title>

      <para>From the Hadoop website, it<quote>is a software platform that lets
        one easily write and run applications that process vast amounts of
        data</quote>. Hadoop does this by providing a storage layer that holds
        vast amounts of data, and an execution layer that runs an application in
        parallel across the cluster, using coordinated subsets of the stored
        data.
      </para>

      <para>The storage layer, called the Hadoop File System (HDFS), looks
        like a single storage volume that has been optimized for many concurrent
        serialized reads of large data files - where "large" might be measured
        in gigabytes or petabytes. However, it does have limitations. For
        example, random access to the data is not really possible in an
        efficient manner. And Hadoop only supports a single writer for output.
        But this limit helps make Hadoop very performant and reliable, in part
        because it allows for the data to be replicated across the cluster,
        reducing the chance of data loss.
      </para>

      <para>The execution layer, called MapReduce, relies on a
        divide-and-conquer strategy to manage massive data sets and computing
        processes. Explaining MapReduce is beyond the scope of this document,
        but its complexity, and the difficulty of creating real-world
        applications against it, are the chief driving force behind the creation
        of Cascading.
      </para>

      <para>Hadoop, according to its documentation, can be configured to run
        in three modes: standalone mode (i.e., on the local computer, useful for
        testing and debugging), pseudo-distributed mode (i.e., on an emulated
        "cluster" of one computer, useful for testing), and fully-distributed
        mode (on a full cluster, for production purposes). The
        pseudo-distributed mode does not add value for most purposes, and will
        not be discussed further. Cascading itself can run locally or on the
        Hadoop platform, where Hadoop itself may be in standalone or distributed
        mode. The primary difference between these two platforms is that, when
        Cascading is running locally, it makes no use of Hadoop APIs and
        performs all of its work in memory, allowing it to be very fast - but
        consequently not as robust or scalable as when it is running on the
        Hadoop platform.
      </para>

      <para>Apache Hadoop is an Open Source Apache project and is freely
        available. It can be downloaded from the Hadoop website:<link
          xlink:href="http://hadoop.apache.org/core/">http://hadoop.apache.org/core/</link>.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Diving In</title>
    </info>

    <para>The most common example presented to new Hadoop (and MapReduce)
      developers is an application that counts words. It is the Hadoop
      equivalent to a "Hello World" application.
    </para>

    <para>In the word-counting application, a document is parsed into
      individual words and the frequency of each word is counted. In the last
      paragraph, for example, "is" appears twice and "equivalent" appears
      once.
    </para>

    <para>The following code example uses Cascading to read each line of text
      from our document file, parse it into words, then count the number of
      times each word appears.
    </para>

    <example>
      <title>Word Counting</title>

      <xi:include href="basic-word-count.xml"/>
    </example>

    <para>Several features of this example are worth highlighting.</para>

    <para>First, notice that the pipe assembly is not coupled to the data
      (i.e., the
      <classname>Tap</classname>
      instances) until the last moment
      before execution. File paths or references are not embedded in the pipe
      assembly; instead, the pipe assembly is specified independent of data
      inputs and outputs. The only dependency is the data scheme, i.e., the
      field names. In Cascading, every input or output file has field names
      associated with it, and every processing element of the pipe assembly
      either expects the specified fields or creates them. This allows
      developers to easily self-document their code, and allows the Cascading
      planner to "fail fast" if an expected dependency between elements isn't
      satisfied - for instance, if a needed field name is missing or incorrect.
      (If more information is desired on the planner, see<xref
        linkend="job-planner"/>.)
    </para>

    <para>Also notice that pipe assemblies are assembled through constructor
      chaining. This may seem odd, but it is done for two reasons. First, it
      keeps the code more concise. Second, it prevents developers from creating
      "cycles" (i.e., recursive loops) in the resulting pipe assembly. Pipe
      assemblies are intended to be Directed Acyclic Graphs (DAG's), and in
      keeping with this, the Cascading planner is not designed to handle
      processes that feed themselves. (If desired, there are safer approaches to
      achieving this result.
    </para>

    <para>Finally, notice that the very first
      <code>Pipe</code>
      instance has a
      name. That instance is the
      <emphasis role="italic">head</emphasis>
      of this
      particular pipe assembly. Pipe assemblies can have any number of heads,
      and any number of<emphasis role="italic">tails</emphasis>. Although the
      tail in this example does not have a name, in a more complex assembly it
      would. In general, heads and tails of pipe assemblies are assigned names
      to disambiguate them. One reason is that names are used to bind sources
      and sinks to pipes during planning. (The example above is an exception,
      because there is only one head and one tail - and consequently only one
      source and one sink - so the binding is unmistakable.) Another reason is
      that the naming of pipes contributes to self-documention of pipe
      assemblies, especially where there are splits, joins, and merges in the
      assembly.
    </para>

    <para>To sum up, the example word-counting application will:</para>

    <itemizedlist>
      <listitem>
        <para>Read each line of text from a file and give it the field name
          "line"
        </para>
      </listitem>

      <listitem>
        <para>parse each "line" into words with the
          <code>RegexGenerator</code>
          object, which returns each word in the
          field named "word"
        </para>
      </listitem>

      <listitem>
        <para>sort and group all the tuples on the "word" field, using the
          <code>GroupBy</code>
          object
        </para>
      </listitem>

      <listitem>
        <para>count the number of elements in each group, using the
          <code>Count</code>
          object, and store this value in the "count"
          field
        </para>
      </listitem>

      <listitem>
        <para>and write out the "word" and "count" fields.</para>
      </listitem>
    </itemizedlist>
  </chapter>

  <chapter>
    <info>
      <title>Data Processing</title>
    </info>

    <section>
      <title>Terminology</title>

      <para>The Cascading processing model is based on a metaphor of pipes
        (data streams) and filters (data operations). Thus the Cascading API
        allows the developer to assemble pipe assemblies that split, merge,
        group, or join streams of data while applying operations to each data
        record or groups of records.
      </para>

      <para>In Cascading, we call a data record a<emphasis
        role="italic">tuple</emphasis>, a simple chain of pipes without forks or
        merges a<emphasis role="italic">branch</emphasis>, an interconnected set
        of pipe branches a<emphasis>pipe assembly</emphasis>, and a series of
        tuples passing through a pipe branch or assembly a<emphasis
          role="italic">tuple stream</emphasis>.
      </para>

      <para>Pipe assemblies are specified independently of the data source
        they are to process. So before a pipe assembly can be executed, it must
        be bound to<emphasis role="italic">taps</emphasis>, i.e., data sources
        and sinks. The result of binding one or more pipe assemblies to taps is
        a<emphasis role="italic">flow</emphasis>, which is executed on a
        computer or cluster using the Hadoop framework.
      </para>

      <para>Multiple flows can be grouped together and executed as a single
        process. In this context, if one flow depends on the output of another,
        it is not executed until all of its data dependencies are satisfied.
        Such a collection of flows is called a<emphasis
          role="italic">cascade</emphasis>.
      </para>
    </section>

    <section>
      <title>Pipe Assemblies</title>

      <para>Pipe assemblies define what work should be done against tuple
        streams, which are read from tap
        <emphasis role="italic">sources
        </emphasis>
        and written to tap<emphasis role="italic">sinks</emphasis>.
        The work performed on the data stream may include actions such as
        filtering, transforming, organizing, and calculating. Pipe assemblies
        may use multiple sources and multiple sinks, and may define splits,
        merges, and joins to manipulate the tuple streams.
      </para>

      <section>
        <title>Pipe Assembly Workflow</title>

        <para>Pipe assemblies are created by chaining
          <classname>cascading.pipe.Pipe</classname>
          classes and subclasses
          together. Chaining is accomplished by passing the previous
          <classname>Pipe</classname>
          instances to the constructor of the next
          <classname>Pipe</classname>
          instance.
        </para>

        <para>The following example demonstrates this type of chaining. It
          creates two pipes - a "left-hand side" (lhs) and a "right-hand side"
          (rhs) - and performs some processing on them both, using the Each
          pipe. Then it joins the two pipes into one, using the CoGroup pipe,
          and performs several operations on the joined pipe using Every and
          GroupBy. The specific operations performed are not important in the
          example; the point is to show the general flow of the data streams.
          The diagram after the example gives a visual representation of the
          workflow.
        </para>

        <example>
          <title xreflabel="Chaining Pipes" xml:id="chaining-pipes">Chaining
            Pipes
          </title>

          <xi:include href="simple-pipe-assembly.xml"/>
        </example>

        <para>The following diagram is a visual representation of the example
          above.
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="5.4in"
                       fileref="images/simple-pipe-assembly.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="5.4in"
                       fileref="images/simple-pipe-assembly.png"/>
          </imageobject>
        </mediaobject>
      </section>

      <section>
        <title>Common Stream Patterns</title>

        <para>As data moves through the pipe, streams may be separated or
          combined for various purposes. Here are the three basic
          patterns:
        </para>

        <variablelist>
          <varlistentry>
            <term>Split</term>

            <listitem>
              <para>A split takes a single stream and sends it down multiple
                paths - that is, it feeds a single
                <classname>Pipe</classname>
                instance into two or more subsequent separate
                <classname>Pipe</classname>
                instances with unique branch
                names.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Merge</term>

            <listitem>
              <para>A merge combines two or more streams that have identical
                fields into a single stream. This is done by passing two or more
                <classname>Pipe</classname>
                instances to a
                <classname>Merge</classname>
                or
                <classname>GroupBy</classname>
                pipe.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Join</term>

            <listitem>
              <para>A join combines data from two or more streams that have
                different fields, based on common field values (analogous to a
                SQL join.) This is done by passing two or more
                <classname>Pipe</classname>
                instances to a
                <classname>HashJoin</classname>
                or
                <classname>CoGroup</classname>
                pipe. The code sequence and
                diagram above give an example.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>Data Processing</title>

        <para>In addition to directing the tuple streams - using splits,
          merges, and joins - pipe assemblies can examine, filter, organize, and
          transform the tuple data as the streams move through the pipe
          assemblies. To facilitate this, the values in the tuple are typically
          given field names, just as database columns are given names, so that
          they may be referenced or selected. The following terminology is
          used:
        </para>

        <variablelist>
          <varlistentry>
            <term>Operation</term>

            <listitem>
              <para>Operations
                (<classname>cascading.operation.Operation</classname>) accept an
                input argument Tuple, and output zero or more result tuples.
                There are a few sub-types of operations defined below. Cascading
                has a number of generic Operations that can be used, or
                developers can create their own custom Operations.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Tuple</term>

            <listitem>
              <para>In Cascading, data is processed as a stream of Tuples
                (<classname>cascading.tuple.Tuple</classname>), which are
                composed of fields, much like a database record or row. A Tuple
                is effectively an array of (field) values, where each value can
                be any
                <classname>java.lang.Object</classname>
                Java type (or
                <code>byte[]</code>
                array). For information on supporting
                non-primitive types, see<xref linkend="custom-types"/>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields</term>

            <listitem>
              <para>Fields (<classname>cascading.tuple.Fields</classname>) are
                used either to declare the field names for fields in a Tuple, or
                reference field values in a Tuple. They can either be strings
                (such as "firstname" or "birthdate"), integers (for the field
                position, starting at
                <code>0</code>
                for the first position, or
                starting at
                <code>-1</code>
                for the last position), or one of
                the predefined
                <emphasis role="italic">Fields sets</emphasis>
                (such as<code>Fields.ALL</code>, which selects all values in the
                Tuple, like an asterisk in SQL). For more on Fields sets,
                see<xref linkend="field-algebra"/>).
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section>
      <title>Pipes</title>

      <para>The code for the sample pipe assembly above,<xref
        linkend="chaining-pipes"/>, consists almost entirely of a series of
        <classname>Pipe</classname>
        constructors. This section describes the
        various
        <classname>Pipe</classname>
        classes in detail. The base class
        <classname>cascading.pipe.Pipe</classname>
        and its subclasses are shown
        in the diagram below.
      </para>

      <mediaobject>
        <imageobject role="fo">
          <imagedata align="center" contentwidth="5in"
                     fileref="images/pipes.svg"/>
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" contentwidth="5in"
                     fileref="images/pipes.png"/>
        </imageobject>
      </mediaobject>

      <section>
        <title>Types of Pipes</title>

        <variablelist>
          <para>
            <emphasis role="bold">The
              <classname>Pipe</classname>
              class
            </emphasis>
            is used to instantiate and name a pipe. Pipe names are
            used by the planner to bind taps to the pipe as sources or sinks. (A
            third option is to bind a tap to the pipe branch as a<emphasis
            role="italic">trap</emphasis>, discussed elsewhere as an advanced
            topic.)
          </para>

          <para>
            <emphasis role="bold">The
              <classname>SubAssembly</classname>
              subclass
            </emphasis>
            is a special type of pipe. It is used to nest
            re-usable pipe assemblies within a
            <classname>Pipe</classname>
            class
            for inclusion in a larger pipe assembly. For more information on
            this, see the section on<xref linkend="subassemblies"/>.
          </para>

          <para>
            <emphasis role="bold">The other six types of pipes</emphasis>
            are used to perform operations on the tuple streams as they pass
            through the pipe assemblies. This may involve operating on the
            individual tuples (e.g., transform or filter), on groups of related
            tuples (e.g., count or subtotal), or on entire streams (e.g., split,
            combine, group, or sort). These six pipe types are briefly
            introduced here, then explored in detail further below.
          </para>

          <varlistentry>
            <term>
              <classname>Each</classname>
            </term>

            <listitem>
              <para>These pipes perform operations based on the data contents
                of tuples - analyze, transform, or filter. The
                <classname>Each</classname>
                pipe operates on individual tuples
                in the stream, applying functions or filters such as
                conditionally replacing certain field values, removing tuples
                that have values outside a target range, etc.
              </para>

              <para>You can also use
                <classname>Each</classname>
                to split or
                branch a stream, simply by routing the output of an
                <classname>Each</classname>
                into a different pipe or
                sink.
              </para>

              <para>Note that with<classname>Each</classname>, as with other
                types of pipe, you can specify a list of fields to output,
                thereby removing unwanted fields from a stream.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <classname>Merge</classname>
            </term>

            <listitem>
              <para>Just as
                <classname>Each</classname>
                can be used to split
                one stream into two,
                <classname>Merge</classname>
                can be used to
                combine two or more streams into one, as long as they have the
                same fields.
              </para>

              <para>A
                <classname>Merge</classname>
                accepts two or more streams
                that have identical fields, and emits a single stream of tuples
                (in arbitrary order) that contains all the tuples from all the
                specified input streams. Thus a Merge is just a mingling of all
                the tuples from the input streams, as if shuffling multiple card
                decks into one.
              </para>

              <para>Use
                <classname>Merge</classname>
                when no grouping is
                required (i.e., no aggregator or buffer operations will be
                performed).
                <classname>Merge</classname>
                is much faster than
                <classname>GroupBy</classname>
                (see below) for merging.
              </para>

              <para>To combine streams that have different fields, based on
                one or more common values, use
                <classname>CoGroup</classname>
                or
                <classname>HashJoin</classname>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <classname>GroupBy</classname>
            </term>

            <listitem>
              <para>
                <classname>GroupBy</classname>
                groups the tuples of a
                stream based on common values in a specified field.
              </para>

              <para>If passed multiple streams as inputs, it performs a merge
                before the grouping. As with<classname>Merge</classname>, a
                <classname>GroupBy</classname>
                requires that multiple input
                streams share the same field structure.
              </para>

              <para>The purpose of grouping is typically to prepare a stream
                for processing by the
                <classname>Every</classname>
                pipe, which
                performs aggregator and buffer operations on the groups, such as
                counting, totalling, or averaging values within that
                group.
              </para>

              <para>It should be clear that "grouping" here essentially means
                sorting all the tuples into groups based on the value of a
                particular field. However, within a given group, the tuples are
                in arbitrary order unless you specify a secondary sort key. For
                most purposes, a secondary sort is not required and only
                increases the execution time.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <classname>Every</classname>
            </term>

            <listitem>
              <para>The
                <classname>Every</classname>
                pipe operates on a tuple
                stream that has been grouped (by
                <classname>GroupBy</classname>
                or<classname>CoGroup</classname>) on the values of a particular
                field, such as timestamp or zipcode. It's used to apply
                aggregator or buffer operations such as counting, totaling, or
                averaging field values within each group. Thus the
                <classname>Every</classname>
                class is only for use on the output
                of
                <classname>GroupBy</classname>
                or
                <classname>CoGroup</classname>, and cannot be used with the
                output of<classname>Each</classname>,
                <classname>Merge</classname>, or
                <classname>HashJoin</classname>.
              </para>

              <para>An
                <classname>Every</classname>
                instance may follow
                another
                <classname>Every</classname>
                instance, so
                <classname>Aggregator</classname>
                operations can be chained.
                This is not true for
                <classname>Buffer</classname>
                operations.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <classname>CoGroup</classname>
            </term>

            <listitem>
              <para>
                <classname>CoGroup</classname>
                performs a join on two or
                more streams, similar to a SQL join, and groups the single
                resulting output stream on the value of a specified field. As
                with SQL, the join can be inner, outer, left, or right.
                Self-joins are permitted, as well as mixed joins (for three or
                more streams) and custom joins. Null fields in the input streams
                become corresponding null fields in the output stream.
              </para>

              <para>The resulting output stream contains fields from all the
                input streams. If the streams contain any field names in common,
                they must be renamed to avoid duplicate field names in the
                resulting tuples.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <classname>HashJoin</classname>
            </term>

            <listitem>
              <para>
                <classname>HashJoin</classname>
                performs a join on two or
                more streams, similar to a SQL join, and emits a single stream
                in arbitrary order. As with SQL, the join can be inner, outer,
                left, or right. Self-joins are permitted, as well as mixed joins
                (for three or more streams) and custom joins. Null fields in the
                input streams become corresponding null fields in the output
                stream.
              </para>

              <para>For applications that do not require grouping,
                <classname>HashJoin</classname>
                provides faster execution than
                <classname>CoGroup</classname>, but only within certain
                prescribed cases. It is optimized for joining one or more small
                streams to no more than one large stream. Developers should
                thoroughly understand the limitations of this class, as
                described below, before attempting to use it.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The following table summarizes the different types of
          pipes.
        </para>

        <table colsep="1" rowsep="1">
          <title>Comparison of pipe types</title>

          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="100px"/>

            <colspec colname="c2" colnum="2"/>

            <colspec colname="c3" colnum="3"/>

            <colspec colname="c4" colnum="4"/>

            <tbody>
              <row>
                <entry>
                  <emphasis role="bold">
                    <emphasis role="underline">Pipe
                      type
                    </emphasis>
                  </emphasis>
                </entry>

                <entry>
                  <emphasis role="underline">
                    <emphasis
                      role="bold">Purpose
                    </emphasis>
                  </emphasis>
                </entry>

                <entry>
                  <emphasis role="underline">
                    <emphasis role="bold">Input
                    </emphasis>
                  </emphasis>
                </entry>

                <entry>
                  <emphasis role="underline">
                    <emphasis
                      role="bold">Output
                    </emphasis>
                  </emphasis>
                </entry>
              </row>

              <row>
                <entry>
                  <classname>Pipe</classname>
                </entry>

                <entry>instantiate a pipe; create or name a branch</entry>

                <entry>name</entry>

                <entry>a (named) pipe</entry>
              </row>

              <row>
                <entry>
                  <classname>SubAssembly</classname>
                </entry>

                <entry>create nested subassemblies</entry>

                <entry/>

                <entry/>
              </row>

              <row>
                <entry>
                  <classname>Each</classname>
                </entry>

                <entry>apply a filter or function, or branch a stream</entry>

                <entry>tuple stream (grouped or not)</entry>

                <entry>a tuple stream, optionally filtered or
                  transformed
                </entry>
              </row>

              <row>
                <entry>
                  <classname>Merge</classname>
                </entry>

                <entry>merge two or more streams with identical fields</entry>

                <entry>two or more tuple streams</entry>

                <entry>a tuple stream, unsorted</entry>
              </row>

              <row>
                <entry>
                  <classname>GroupBy</classname>
                </entry>

                <entry>sort/group on field values; optionally merge two or
                  more streams with identical fields
                </entry>

                <entry>two or more tuple streams with identical fields</entry>

                <entry>a single tuple stream, grouped on key field(s) with
                  optional secondary sort
                </entry>
              </row>

              <row>
                <entry>
                  <classname>Every</classname>
                </entry>

                <entry>apply aggregator or buffer operation</entry>

                <entry>grouped tuple stream</entry>

                <entry>a tuple stream plus new fields with operation
                  results
                </entry>
              </row>

              <row>
                <entry>
                  <classname>CoGroup</classname>
                </entry>

                <entry>join 1 or more streams on matching field values</entry>

                <entry>one or more tuple streams</entry>

                <entry>a single tuple stream, joined on key field(s)</entry>
              </row>

              <row>
                <entry>
                  <classname>HashJoin</classname>
                </entry>

                <entry>join 1 or more streams on matching field values</entry>

                <entry>one or more tuple streams</entry>

                <entry>a tuple stream in arbitrary order</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title xreflabel="Each and Every Pipes" xml:id="each-every">The Each
          and Every Pipes
        </title>

        <para>The
          <classname>Each</classname>
          and
          <classname>Every</classname>
          pipes perform operations on tuple data - for instance, perform a
          search-and-replace on tuple contents, filter out some of the tuples
          based on their contents, or count the number of tuples in a stream
          that share a common field value.
        </para>

        <para>Here is the syntax for these pipes:</para>

        <para>
          <programlisting>new Each( previousPipe, argumentSelector, operation, outputSelector )</programlisting>
        </para>

        <para>
          <programlisting>new Every( previousPipe, argumentSelector, operation, outputSelector )</programlisting>
        </para>

        <para>Both types take four arguments:</para>

        <para>
          <itemizedlist>
            <listitem>
              <para>a Pipe instance</para>
            </listitem>

            <listitem>
              <para>an argument selector</para>
            </listitem>

            <listitem>
              <para>an Operation instance</para>
            </listitem>

            <listitem>
              <para>an output selector on the constructor (selectors here are
                Fields instances)
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>The key difference between
          <classname>Each</classname>
          and
          <classname>Every</classname>
          is that the
          <classname>Each</classname>
          operates on individual tuples, and
          <classname>Every</classname>
          operates on groups of tuples emitted by
          <classname>GroupBy</classname>
          or<classname>CoGroup</classname>. This affects the kind of operations
          that these two pipes can perform, and the kind of output they produce
          as a result.
        </para>

        <para>The
          <classname>Each</classname>
          pipe applies operations that are
          subclasses of
          <classname>Functions</classname>
          and
          <classname>Filters</classname>
          (described in the Javadoc). For
          example, using
          <classname>Each</classname>
          you can parse lines from a
          logfile into their constituent fields, filter out all lines except the
          HTTP GET requests, and replace the timestring fields with date
          fields.
        </para>

        <para>Similarly, since the
          <classname>Every</classname>
          pipe works on
          tuple groups (the output of a
          <classname>GroupBy</classname>
          or
          <classname>CoGroup</classname>
          pipe), it applies operations that are
          subclasses of
          <classname>Aggregators</classname>
          and
          <classname>Buffers</classname>. For example, you could use
          <classname>GroupBy</classname>
          to group the output of the above
          <classname>Each</classname>
          pipe by date, then use an
          <classname>Every</classname>
          pipe to count the GET requests per date.
          The pipe would then emit the operation results as the date and count
          for each group.
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/pipe-operation-relationship.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/pipe-operation-relationship.png"/>
          </imageobject>
        </mediaobject>

        <para>In the syntax shown at the start of this section, the
          <emphasis
            role="italic">argument selector
          </emphasis>
          specifies fields from the
          input tuple to use as input values. If the argument selector is not
          specified, the whole input tuple (<code>Fields.ALL</code>) is passed
          to the operation as a set of argument values.
        </para>

        <para>Most
          <classname>Operation</classname>
          subclasses declare result
          fields (shown as "declared fields" in the diagram). The
          <emphasis
            role="italic">output selector
          </emphasis>
          specifies the fields of the
          output
          <classname>Tuple</classname>
          from the fields of the input
          <classname>Tuple</classname>
          and the operation result. This new output
          <classname>Tuple</classname>
          becomes the input
          <classname>Tuple</classname>
          to the next pipe in the pipe assembly. If
          the output selector is<code>Fields.ALL</code>, the output is the input
          <classname>Tuple</classname>
          plus the operation result, merged into a
          single<classname>Tuple</classname>.
        </para>

        <para>Note that it's possible for a
          <classname>Function</classname>
          or
          <classname>Aggregator</classname>
          to return more than one output
          <classname>Tuple</classname>
          per input<classname>Tuple</classname>. In
          this case, the input tuple is duplicated as many times as necessary to
          create the necessary output tuples. This is similar to the reiteration
          of values that happens during a join. If a function is designed to
          always emit three result tuples for every input tuple, each of the
          three outgoing tuples will consist of the selected input tuple values
          plus one of the three sets of function result values.
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/each-operation-relationship.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/each-operation-relationship.png"/>
          </imageobject>
        </mediaobject>

        <para>If the result selector is not specified for an
          <classname>Each</classname>
          pipe performing a
          <classname>Functions</classname>
          operation, the operation results are
          returned by default (<code>Fields.RESULTS</code>), discarding the
          input tuple values in the tuple stream. (This is not true of
          <classname>Filters</classname>
          , which either discard the input tuple
          or return it intact, and thus do not use an output selector.)
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/every-operation-relationship.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/every-operation-relationship.png"/>
          </imageobject>
        </mediaobject>

        <para>For the
          <classname>Every</classname>
          pipe, the Aggregator
          results are appended to the input Tuple (<code>Fields.ALL</code>) by
          default.
        </para>

        <para>Note that the
          <classname>Every</classname>
          pipe associates
          <classname>Aggregator</classname>
          results with the current group
          <classname>Tuple</classname>
          (the unique keys currently being grouped
          on). For example, if you are grouping on the field "department" and
          counting the number of "names" grouped by that department, the
          resulting output Fields will be ["department","num_employees"].
        </para>

        <para>If you are also adding up the salaries associated with each
          "name" in each "department", the output Fields will be
          ["department","num_employees","total_salaries"].
        </para>

        <para>This is only true for chains of
          <classname>Aggregator</classname>
          Operations - you are not allowed to
          chain
          <classname>Buffer</classname>
          operations, as explained
          below.
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/buffer-operation-relationship.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="6in"
                       fileref="images/buffer-operation-relationship.png"/>
          </imageobject>
        </mediaobject>

        <para>When the
          <classname>Every</classname>
          pipe is used with a
          <classname>Buffer</classname>
          operation, instead of an
          <classname>Aggregator</classname>, the behavior is different. Instead
          of being associated with the current grouping tuple, the operation
          results are associated with the current values tuple. This is
          analogous to how an
          <classname>Each</classname>
          pipe works with a
          <classname>Function</classname>. This approach may seem slightly
          unintuitive, but provides much more flexibility. To put it another
          way, the results of the buffer operation are not appended to the
          current keys being grouped on. It is up to the buffer to emit them if
          they are relevant. It is also possible for a Buffer to emit more than
          one result Tuple per unique grouping. That is, a Buffer may or may not
          emulate an Aggregator, where an Aggregator is just a special optimized
          case of a Buffer.
        </para>

        <para>For more information on how operations process fields, see
          <xref
            linkend="field-processing"/>
          .
        </para>
      </section>

      <section>
        <title>Merge</title>

        <para>The
          <classname>Merge</classname>
          pipe is very simple. It accepts
          two or more streams that have the same fields, and emits a single
          stream containing all the tuples from all the input streams. Thus a
          merge is just a mingling of all the tuples from the input streams, as
          if shuffling multiple card decks into one. Note that the output of
          <classname>Merge</classname>
          is in arbitrary order.
        </para>

        <example>
          <title>Merging Two Tuple Streams</title>

          <xi:include href="simple-merge.xml"/>
        </example>

        <para>The example above simply combines all the tuples from two
          existing streams ("lhs" and "rhs") into a new tuple stream
          ("merge").
        </para>
      </section>

      <section>
        <title>GroupBy</title>

        <para>
          <classname>GroupBy</classname>
          groups the tuples of a stream
          based on common values in a specified field. If passed multiple
          streams as inputs, it performs a merge before the grouping. As with
          <classname>Merge</classname>, a
          <classname>GroupBy</classname>
          requires that multiple input streams share the same field
          structure.
        </para>

        <para>The output of
          <classname>GroupBy</classname>
          is suitable for the
          <classname>Every</classname>
          pipe, which performs
          <classname>Aggregator</classname>
          and
          <classname>Buffer</classname>
          operations, such as counting, totalling, or averaging groups of tuples
          that have a common value (e.g., the same date). By default,
          <classname>GroupBy</classname>
          performs no secondary sort, so within
          each group the tuples are in arbitrary order. For instance, when
          grouping on "lastname", the tuples
          <code>[doe, john]</code>
          and
          <code>[doe, jane]</code>
          end up in the same group, but in arbitrary
          sequence.
        </para>

        <section>
          <title xml:id="secondary-sorting">Secondary sorting</title>

          <para>If multi-level sorting is desired, the names of the sort
            fields on must be specified to the
            <classname>GroupBy</classname>
            instance, as seen below. In this example,
            <code>value1</code>
            and
            <code>value2</code>
            will arrive in their natural sort order
            (assuming they are
            <classname>java.lang.Comparable</classname>).
          </para>

          <example>
            <title>Secondary Sorting</title>

            <xi:include href="simple-groupby-secondary.xml"/>
          </example>

          <para>If we don't care about the order of<code>value2</code>, we can
            leave it out of the
            <code>sortFields</code>
            <classname>Fields</classname>
            constructor.
          </para>

          <para>In the next example, we reverse the order of
            <code>value1</code>
            while keeping the natural order of
            <code>value2</code>.
          </para>

          <example>
            <title>Reversing Secondary Sort Order</title>

            <xi:include href="simple-groupby-secondary-comparator.xml"/>
          </example>

          <para>Whenever there is an implied sort during grouping or secondary
            sorting, a custom
            <classname>java.util.Comparator</classname>
            can
            optionally be supplied to the grouping
            <classname>Fields</classname>
            or secondary sort<classname>Fields</classname>. This allows the
            developer to use the
            <code>Fields.setComparator()</code>
            call to
            control the sort.
          </para>

          <para>To sort or group on non-Java-comparable classes, consider
            creating a custom<classname>Comparator</classname>.
          </para>

          <para>Below is a more practical example, where we group by the "day
            of the year", but want to reverse the order of the tuples within
            that grouping by "time of day".
          </para>

          <example>
            <title>Reverse Order by Time</title>

            <xi:include href="simple-groupby-secondary-time.xml"/>
          </example>
        </section>
      </section>

      <section>
        <title>CoGroup</title>

        <para>The
          <classname>CoGroup</classname>
          pipe is similar to
          <classname>GroupBy</classname>, but instead of a merge, performs a
          join. That is,
          <classname>CoGroup</classname>
          accepts two or more
          input streams and groups them on one or more specified keys, and
          performs a join operation on equal key values, similar to a SQL
          join.
        </para>

        <para>The output stream contains all the fields from all the input
          streams.
        </para>

        <para>As with SQL, the join can be inner, outer, left, or right.
          Self-joins are permitted, as well as mixed joins (for three or more
          streams) and custom joins. Null fields in the input streams become
          corresponding null fields in the output stream.
        </para>

        <para>Since the output is grouped, it is suitable for the
          <classname>Every</classname>
          pipe, which performs
          <classname>Aggregator</classname>
          and
          <classname>Buffer</classname>
          operations - such as counting, totalling, or averaging groups of
          tuples that have a common value (e.g., the same date).
        </para>

        <para>The output stream is sorted by the natural order of the grouping
          fields. To control this order, at least the first
          <classname>groupingFields</classname>
          value given should be an
          instance of
          <classname>Fields</classname>
          containing
          <classname>Comparator</classname>
          instances for the appropriate
          fields. This allows fine-grained control of the sort grouping
          order.
        </para>

        <section>
          <title>Field names</title>

          <para>In a join operation, all the field names used in any of the
            input tuples must be unique; duplicate field names are not allowed.
            If the names overlap there is a collision, as shown in the following
            diagram.
          </para>

          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" contentwidth="5in"
                         fileref="images/cogrouping-fields-fail.svg"/>
            </imageobject>

            <imageobject role="html">
              <imagedata align="center" contentwidth="5in"
                         fileref="images/cogrouping-fields-fail.png"/>
            </imageobject>
          </mediaobject>

          <para>In this figure, two streams are to be joined on the "url"
            field, resulting in a new Tuple that contains fields from the two
            input tuples. However, the resulting tuple would include two fields
            with the same name ("url"), which is unworkable. To handle the
            conflict, developers can use the
            <parameter>declaredFields</parameter>
            argument (described in the
            Javadoc) to declare unique field names for the output tuple, as in
            the following example.
          </para>

          <example>
            <title>Joining Two Tuple Streams with Duplicate Field
              Names
            </title>

            <xi:include href="duplicate-cogroup.xml"/>
          </example>

          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" contentwidth="5in"
                         fileref="images/cogrouping-fields-pass.svg"/>
            </imageobject>

            <imageobject role="html">
              <imagedata align="center" contentwidth="5in"
                         fileref="images/cogrouping-fields-pass.png"/>
            </imageobject>
          </mediaobject>

          <para>This revised figure demonstrates the use of declared field
            names to prevent a planning failure.
          </para>

          <para>It might seem preferable for Cascading to automatically
            recognize the duplication and simply merge the identically-named
            fields, saving effort for the developer. However, consider the case
            of an outer type join in which one field (or set of fields used for
            the join) for a given join side happens to be<code>null</code>.
            Discarding one of the duplicate fields would lose this
            information.
          </para>

          <para>Further, the internal implementation relies on field position,
            not field names, when reading tuples; the field names are a device
            for the developer. This approach allows the behavior of the
            <classname>CoGroup</classname>
            to be deterministic and
            predictable.
          </para>
        </section>

        <section>
          <title xml:id="joiner-class">The Joiner class</title>

          <para>In the example above, we explicitly specified a Joiner class
            (InnerJoin) to perform a join on our data. There are five Joiner
            subclasses, as shown in this diagram.
          </para>

          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" contentwidth="3.5in"
                         fileref="images/joins.svg"/>
            </imageobject>

            <imageobject role="html">
              <imagedata align="center" contentwidth="3.5in"
                         fileref="images/joins.png"/>
            </imageobject>
          </mediaobject>

          <para>In<classname>CoGroup</classname>, the join is performed after
            all the input streams are first co-grouped by their common keys.
            Cascading must create a "bag" of data for every grouping in the
            input streams, consisting of all the
            <classname>Tuple</classname>
            instances associated with that grouping.
          </para>

          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" contentwidth="5in"
                         fileref="images/cogrouped-values.svg"/>
            </imageobject>

            <imageobject role="html">
              <imagedata align="center" contentwidth="5in"
                         fileref="images/cogrouped-values.png"/>
            </imageobject>
          </mediaobject>

          <para>It's already been mentioned that joins in Cascading are
            analogous to joins in SQL. The most commonly-used type of join is
            the inner join, the default in<classname>CoGroup</classname>. An
            inner join tries to match
            <emphasis role="italic">each</emphasis>
            Tuple on the "lhs" with
            <emphasis role="italic">every</emphasis>
            Tuple on the "rhs", based on matching field values. With an inner
            join, if either side has no tuples for a given value, no tuples are
            joined. An outer join, conversely, allows for either side to be
            empty and simply substitutes a
            <classname>Tuple</classname>
            containing
            <code>null</code>
            values for the non-existent
            tuple.
          </para>

          <para>This sample data is used in the discussion below to explain
            and compare the different types of join:
          </para>

          <para><programlisting>LHS = [0,a] [1,b] [2,c]
            RHS = [0,A] [2,C] [3,D]</programlisting>In each join type
            below, the values are joined on the first tuple position (the join
            key), a numeric value. Note that, when Cascading joins tuples, the
            resulting
            <classname>Tuple</classname>
            contains all the incoming
            values from in incoming tuple streams, and does not discard the
            duplicate key fields. As mentioned above, on outer joins where there
            is no equivalent key in the alternate stream,
            <code>null</code>
            values are used.
          </para>

          <para>For example using the data above, the result Tuple of an
            "inner" join with join key value of
            <code>2</code>
            would be
            <code>[2,c,2,C]</code>. The result Tuple of an "outer" join with
            join key value of
            <code>1</code>
            would be
            <code>[1,b,null,null]</code>.
          </para>

          <para>
            <variablelist>
              <varlistentry>
                <term>InnerJoin</term>

                <listitem>
                  <para>An inner join only returns a joined
                    <classname>Tuple</classname>
                    if neither bag for the join key
                    is empty.
                    <programlisting>[0,a,0,A] [2,c,2,C]</programlisting>
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>OuterJoin</term>

                <listitem>
                  <para>An outer join performs a join if one bag (left or
                    right) for the join key is empty, or if neither bag is
                    empty.
                    <programlisting>[0,a,0,A] [1,b,null,null] [2,c,2,C] [null,null,3,D]</programlisting>
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>LeftJoin</term>

                <listitem>
                  <para>A left join can also be stated as a left inner and
                    right outer join, where it is acceptable for the right bag
                    to be empty (but not the left).
                  </para>

                  <programlisting>[0,a,0,A] [1,b,null,null] [2,c,2,C]</programlisting>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>RightJoin</term>

                <listitem>
                  <para>A right join can also be stated as a left outer and
                    right inner join, where it is acceptable for the left bag to
                    be empty (but not the right).
                    <programlisting>[0,a,0,A] [2,c,2,C] [null,null,3,D]</programlisting>
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>MixedJoin</term>

                <listitem>
                  <para>A mixed join is where 3 or more tuple streams are
                    joined, using a small Boolean array to specify each of the
                    join types to use. For more information, see the
                    <classname>cascading.pipe.cogroup.MixedJoin</classname>
                    class in the Javadoc.
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>
                  <emphasis>Custom</emphasis>
                </term>

                <listitem>
                  <para>Developers can subclass the
                    <classname>cascading.pipe.cogroup.Joiner</classname>
                    class
                    to create custom join operations.
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
        </section>

        <section>
          <title>Scaling</title>

          <para>
            <classname>CoGroup</classname>
            attempts to store the entire
            current unique keys tuple "bag" from the right-hand stream in memory
            for rapid joining to the left-hand stream. If the bag is very large,
            it may exceed a configurable threshold and be spilled to disk,
            reducing performance and potentially causing a memory error (if the
            threshold value is too large). Thus it's usually best to put the
            stream with the largest groupings on the left-hand side and, if
            necessary, adjust the spill threshold as described in the
            Javadoc.
          </para>
        </section>
      </section>

      <section>
        <title>HashJoin</title>

        <para>
          <classname>HashJoin</classname>
          performs a join (similar to a
          SQL join) on two or more streams, and emits a stream of tuples that
          contain fields from all of the input streams. With a join, the tuples
          in the different input streams do not typically contain the same set
          of fields.
        </para>

        <para>As with<classname>CoGroup</classname>, the fieldnames must all
          be unique, including the names of the key fields, to avoid duplicate
          field names in the emitted<classname>Tuple</classname>. If necessary,
          use the
          <parameter>declaredFields</parameter>
          argument to specify
          unique field names for the output.
        </para>

        <para>An inner join is performed by default, but you can choose inner,
          outer, left, right, or mixed (three or more streams). Self-joins are
          permitted. Developers can also create custom Joiners if desired. For
          more information on types of joins, refer to
          <xref
            linkend="joiner-class"/>
          or the Javadoc.
        </para>

        <example>
          <title>Joining Two Tuple Streams</title>

          <xi:include href="simple-join.xml"/>
        </example>

        <para>The example above performs an inner join on two streams ("lhs"
          and "rhs"), based on common values in two fields. The field names that
          are specified in
          <classname>lhsFields</classname>
          and
          <classname>rhsFields</classname>
          are among the field names previously
          declared for the two input streams.
        </para>

        <section>
          <title>Scaling</title>

          <para>For joins that do not require grouping,
            <classname>HashJoin</classname>
            provides faster execution than
            <classname>CoGroup</classname>, but it operates within stricter
            limitations. It is optimized for joining one or more small streams
            to no more than one large stream.
          </para>

          <para>Unlike<classname>CoGroup</classname>,
            <classname>HashJoin</classname>
            attempts to keep the entire
            right-hand stream in memory for rapid comparison (not just the
            current grouping, as no grouping is performed for a
            <classname>HashJoin</classname>). Thus a very large tuple stream in
            the right-hand stream may exceed a configurable spill-to-disk
            threshold, reducing performance and potentially causing a memory
            error. For this reason, it's advisable to use the smaller stream on
            the right-hand side. Additionally, it may be helpful to adjust the
            spill threshold as described in the Javadoc.
          </para>

          <para>Due to the potential difficulties of using
            <classname>HashJoin</classname>
            (as compared to the slower but much
            more reliable<classname>CoGroup</classname>), developers should
            thoroughly understand this class before attempting to use it.
          </para>

          <para>Frequently the
            <classname>HashJoin</classname>
            is fed a
            filtered down stream of Tuples from what was originally a very large
            file. To prevent the large file from being replicated throughout a
            cluster, when running in Hadoop mode, use a
            <classname>Checkpoint</classname>
            pipe at the point where the data
            has been filtered down to its smallest before it is streamed into a
            <classname>HashJoin</classname>. This will force the Tuple stream to
            be persisted to disk and new
            <classname>FlowStep</classname>
            (MapReduce job) to be created to read the smaller data size more
            efficiently.
          </para>
        </section>
      </section>

      <section>
        <title>Setting Custom Pipe Properties</title>

        <para>By default, the properties passed to a FlowConnector subclass
          become the defaults for every Flow instance created by that
          FlowConnector. In the past, if some of the Flow instances needed
          different properties, it was necessary to create additional
          FlowConnectors to set those properties. However, it is now possible to
          set properties at the Pipe scope and at the process FlowStep
          scope.
        </para>

        <para>Setting properties at the Pipe scope lets you set a property
          that is only visible to a given Pipe instance (and its child
          Operation). This allows Operations such as custom Functions to be
          dynamically configured.
        </para>

        <para>More importantly, setting properties at the process FlowStep
          scope allows you to set properties on a Pipe that are inherited by the
          underlying process during runtime. When running on the Apache Hadoop
          platform (i.e., when using the HadoopFlowConnector), a FlowStep is the
          current MapReduce job. Thus a Hadoop-specific property can be set on a
          Pipe, such as a CoGroup. During runtime, the FlowStep (MapReduce job)
          that the CoGroup executes in is configured with the given property -
          for example, a spill threshold, or the number of reducer tasks for
          Hadoop to deploy.
        </para>

        <para>The following code samples demonstrates the basic form for both
          the Pipe scope and the process FlowStep scope.
        </para>

        <example>
          <title>Pipe Scope</title>

          <xi:include href="properties-pipe.xml"/>
        </example>

        <example>
          <title>Step Scope</title>

          <xi:include href="properties-step.xml"/>
        </example>
      </section>
    </section>

    <section>
      <title xreflabel="Platforms" xml:id="platforms">Platforms</title>

      <para linkend="platforms">Cascading supports pluggable planners that
        allow it to execute on differing platforms. Planners are invoked by an
        associated
        <classname>FlowConnector</classname>
        subclass. Currently,
        only two planners are provided, as described below:
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>LocalFlowConnector</term>

            <listitem>
              <para>The
                <classname>cascading.flow.local.LocalFlowConnector</classname>
                provides a "local" mode planner for running Cascading completely
                in memory on the current computer. This allows for fast
                execution of Flows against local files or any other compatible
                custom
                <classname>Tap</classname>
                and
                <classname>Scheme</classname>
                classes.
              </para>

              <para>The local mode planner and platform were not designed to
                scale beyond available memory, CPU, or disk on the current
                machine. Thus any memory-intensive processes that use
                <classname>GroupBy</classname>,<classname>CoGroup</classname>,
                or
                <classname>HashJoin</classname>
                are likely to fail against
                moderately large files.
              </para>

              <para>Local mode is useful for development, testing, and
                interactive data exploration against sample sets.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>HadoopFlowConnector</term>

            <listitem>
              <para>The
                <classname>cascading.flow.hadoop.HadoopFlowConnector</classname>
                provides a planner for running Cascading on an Apache Hadoop
                cluster. This allows Cascading to execute against extremely
                large data sets over a cluster of computing nodes.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        Cascading's support for pluggable planners allows a
        pipe assembly to be executed on an arbitrary platform, using
        platform-specific Tap and Scheme classes that hide the platform-related
        I/O details from the developer. For example, Hadoop uses
        <classname>org.apache.hadoop.mapred.InputFormat</classname>
        to read
        data, but local mode is happy with a
        <classname>java.io.FileInputStream</classname>. This detail is hidden
        from developers unless they are creating custom Tap and Scheme
        classes.
      </para>
    </section>

    <section>
      <title xreflabel="Source and Sink Taps" xml:id="source-sink">Source and
        Sink Taps
      </title>

      <para>All input data comes in from, and all output data goes out to,
        some instance of<classname>cascading.tap.tap</classname>. A tap
        represents a data resource - such as a file on the local file system, on
        a Hadoop distributed file system, or on Amazon S3. A tap can be read
        from, which makes it a<emphasis role="italic">source</emphasis>, or
        written to, which makes it a<emphasis role="italic">sink</emphasis>. Or,
        more commonly, taps act as both sinks and sources when shared between
        flows.
      </para>

      <para>The platform on which your application is running (Cascading local
        or Hadoop) determines which specific classes you can use. Details are
        provided in the sections below.
      </para>

      <section>
        <title>Schemes</title>

        <para>If the Tap is about where the data is and how to access it, the
          Scheme is about what the data is and how to read it. Every Tap must
          have a Scheme that describes the data. Cascading provides four Scheme
          classes:
        </para>

        <variablelist>
          <varlistentry>
            <term>TextLine</term>

            <listitem>
              <para>TextLine reads and writes raw text files and returns tuples which, by default,
                contain two fields specfic to the platform used. The first field is either the byte
                offset or line number, and the second field is the actual line of text. When written
                to, all Tuple values are converted to Strings delimited with the TAB character (\t).
                A TextLine scheme is provided for both the local and Hadoop modes.
              </para>
              <para>By default TextLine uses the UTF-8 character set. This can be overriden on the
                appropriate TextLine constuctor.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>TextDelimited</term>

            <listitem>
              <para>TextDelimited reads and writes character-delimited files
                in standard formats such as CSV (comma-separated variables), TSV
                (tab-separated variables), and so on. When written to, all Tuple
                values are converted to Strings and joined with the specified
                character delimiter. This Scheme can optionally handle quoted
                values with custom quote characters. Further, TextDelimited can
                coerce each value to a primitive type when reading a text file.
                A TextDelimited scheme is provided for both the local and Hadoop
                modes.
              </para>
              <para>By default TextDelimited uses the UTF-8 character set. This can be overriden on
                appropriate the TextDelimited constuctor.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>SequenceFile</term>

            <listitem>
              <para>SequenceFile is based on the Hadoop Sequence file, which
                is a binary format. When written to or read from, all Tuple
                values are saved in their native binary form. This is the most
                efficient file format - but be aware that the resulting files
                are binary and can only be read by Hadoop applications running
                on the Hadoop platform.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>WritableSequenceFile</term>

            <listitem>
              <para>Like the SequenceFile Scheme, WritableSequenceFile is
                based on the Hadoop Sequence file, but it was designed to read
                and write key and/or value Hadoop
                <classname>Writable</classname>
                objects directly. This is very
                useful if you have sequence files created by other applications.
                During writing (sinking), specified key and/or value fields are
                serialized directly into the sequence file. During reading
                (sourcing), the key and/or value objects are deserialized and
                wrapped in a Cascading Tuple object and passed to the downstream
                pipe assembly. This class is only available when running on the
                Hadoop platform.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>There's a key difference between the
          <classname>TextLine</classname>
          and
          <classname>SequenceFile</classname>
          schemes. With the
          <classname>SequenceFile</classname>
          scheme, data is stored as binary
          tuples, which can be read without having to be parsed. But with the
          <classname>TextLine</classname>
          option, Cascading must parse each line
          into a
          <classname>Tuple</classname>
          before processing it, causing a
          performance hit.
        </para>

        <section>
          <title>Platform-specific implementation details</title>

          <para>Depending on which platform you use (Cascading local or
            Hadoop), the classes you use to specify schemes will vary.
            Platform-specific details for each standard scheme are shown
            below.
          </para>

          <table frame="all">
            <title>Platform-specific tap scheme classes</title>

            <tgroup cols="3">
              <colspec align="left" colname="c1" colnum="1"/>

              <colspec align="left" colname="c2" colnum="2"/>

              <colspec align="left" colname="c3" colnum="3"/>

              <tbody>
                <row>
                  <entry>
                    <emphasis role="bold">Description</emphasis>
                  </entry>

                  <entry>
                    <emphasis role="bold">Cascading local platform
                    </emphasis>
                  </entry>

                  <entry>
                    <emphasis role="bold">Hadoop platform
                    </emphasis>
                  </entry>
                </row>

                <row>
                  <entry>
                    <emphasis role="bold">Package Name</emphasis>
                  </entry>

                  <entry>
                    <classname>cascading.scheme.local</classname>
                  </entry>

                  <entry>
                    <classname>cascading.scheme.hadoop</classname>
                  </entry>
                </row>

                <row>
                  <entry>Read lines of text</entry>

                  <entry>
                    <classname>TextLine</classname>
                  </entry>

                  <entry>
                    <classname>TextLine</classname>
                  </entry>
                </row>

                <row>
                  <entry>Read delimited text (CSV, TSV, etc)</entry>

                  <entry>
                    <classname>TextDelimited</classname>
                  </entry>

                  <entry>
                    <classname>TextDelimited</classname>
                  </entry>
                </row>

                <row>
                  <entry>Cascading proprietary efficient binary</entry>

                  <entry/>

                  <entry>
                    <classname>SequenceFile</classname>
                  </entry>
                </row>

                <row>
                  <entry>External Hadoop application binary (custom
                    <classname>Writable</classname>
                    type)
                  </entry>

                  <entry/>

                  <entry>
                    <classname>WritableSequenceFile</classname>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section>
          <title>Sequence File Compression</title>

          <para>For best performance when running on the Hadoop platform,
            enable Sequence File Compression in the Hadoop property settings -
            either block or record-based compression. Refer to the Hadoop
            documentation for the available properties and compression
            types.
          </para>
        </section>
      </section>

      <section>
        <title>Taps</title>

        <para>The following sample code creates a new Hadoop FileSystem Tap
          that can read and write raw text files. Since only one field name is
          provided, the "offset" field is discarded, resulting in an input tuple
          stream with only "line" values.
        </para>

        <example>
          <title>Creating a new tap</title>

          <xi:include href="simple-tap.xml"/>
        </example>

        <para>Here are the most commonly-used tap types:</para>

        <variablelist>
          <varlistentry>
            <term>FileTap</term>

            <listitem>
              <para>The
                <classname>cascading.tap.local.FileTap</classname>
                tap
                is used with the Cascading local platform to access files on the
                local file system.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Hfs</term>

            <listitem>
              <para>The
                <classname>cascading.tap.hadoop.Hfs</classname>
                tap
                uses the current Hadoop default file system, when running on the
                Hadoop platform.
              </para>

              <para>If Hadoop is configured for "Hadoop local mode" (not to be
                confused with Cascading local mode), its default file system is
                the local file system. If configured for distributed mode, its
                default file system is typically the Hadoop distributed file
                system.
              </para>

              <para>Note that Hadoop can be forced to use an external file
                system by specifying a prefix to the URL passed into a new Hfs
                tap. For instance, using "s3://somebucket/path" tells Hadoop to
                use the S3
                <classname>FileSystem</classname>
                implementation to
                access files in an Amazon S3 bucket. More information on this
                can be found in the Javadoc.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Also provided are four utility taps:</para>

        <variablelist>
          <varlistentry>
            <term>MultiSourceTap</term>

            <listitem>
              <para>The
                <classname>cascading.tap.MultiSourceTap</classname>
                is
                used to tie multiple tap instances into a single tap for use as
                an input source. The only restriction is that all the tap
                instances passed to a new MultiSourceTap share the same Scheme
                classes (not necessarily the same Scheme instance).
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>MultiSinkTap</term>

            <listitem>
              <para>The
                <classname>cascading.tap.MultiSinkTap</classname>
                is
                used to tie multiple tap instances into a single tap for use as
                output sinks. At runtime, for every Tuple output by the pipe
                assembly, each child tap to the MultiSinkTap will sink the
                Tuple.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>TemplateTap</term>

            <listitem>
              <para>The
                <classname>cascading.tap.hadoop.TemplateTap</classname>
                is used
                to sink tuples into directory paths based on the values in the
                Tuple. More can be read below in<xref
                  linkend="template-tap"/>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>GlobHfs</term>

            <listitem>
              <para>The
                <classname>cascading.tap.hadoop.GlobHfs</classname>
                tap accepts Hadoop style "file globbing" expression patterns.
                This allows for multiple paths to be used as a single source,
                where all paths match the given pattern. This tap is only
                available when running on the Hadoop platform.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <section>
          <title>Platform-specific implementation details</title>

          <para>Depending on which platform you use (Cascading local or
            Hadoop), the classes you use to specify file systems will vary.
            Platform-specific details for each standard tap type are shown
            below.
          </para>

          <table frame="all">
            <title>Platform-specific details for setting file system</title>

            <tgroup cols="4">
              <colspec align="left" colname="c1" colnum="1" colwidth="2*"/>

              <colspec align="left" colname="c2" colnum="2" colwidth="3*"/>

              <colspec align="left" colname="c3" colnum="3" colwidth="3*"/>

              <colspec align="left" colname="c4" colnum="4" colwidth="3*"/>

              <tbody>
                <row>
                  <entry>
                    <emphasis role="bold">Description</emphasis>
                  </entry>

                  <entry>
                    <emphasis role="bold">Either platform
                    </emphasis>
                  </entry>

                  <entry>
                    <emphasis role="bold">Cascading local platform
                    </emphasis>
                  </entry>

                  <entry>
                    <emphasis role="bold">Hadoop platform
                    </emphasis>
                  </entry>
                </row>

                <row>
                  <entry>
                    <emphasis role="bold">Package Name</emphasis>
                  </entry>

                  <entry>
                    <classname>cascading.tap</classname>
                  </entry>

                  <entry>
                    <classname>cascading.tap.local</classname>
                  </entry>

                  <entry>
                    <classname>cascading.tap.hadoop</classname>
                  </entry>
                </row>

                <row>
                  <entry>File access</entry>

                  <entry/>

                  <entry>
                    <classname>FileTap</classname>
                  </entry>

                  <entry>
                    <classname>Hfs</classname>
                  </entry>
                </row>

                <row>
                  <entry>Multiple Taps as single source</entry>

                  <entry>
                    <classname>MultiSourceTap</classname>
                  </entry>

                  <entry/>

                  <entry/>
                </row>

                <row>
                  <entry>Multiple Taps as single sink</entry>

                  <entry>
                    <classname>MultiSinkTap</classname>
                  </entry>

                  <entry/>

                  <entry/>
                </row>

                <row>
                  <entry>Bin/Partition data into multiple files</entry>

                  <entry/>

                  <entry>
                    <classname>TemplateTap</classname>
                  </entry>

                  <entry>
                    <classname>TemplateTap</classname>
                  </entry>
                </row>

                <row>
                  <entry>Pattern match multiple files/dirs</entry>

                  <entry/>

                  <entry/>

                  <entry>
                    <classname>GlobHfs</classname>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section>
    </section>

    <section>
      <title>Sink modes</title>

      <para>
        <example>
          <title>Overwriting An Existing Resource</title>

          <xi:include href="simple-replace-tap.xml"/>
        </example>
      </para>

      <para>All applications created with Cascading read data from one or more
        sources, process it, then write data to one or more sinks. This is done
        via the various
        <classname>Tap</classname>
        classes, where each class
        abstracts different types of back-end systems that store data as files,
        tables, blobs, and so on. But in order to sink data, some systems
        require that the resource (e.g., a file) not exist before processing
        thus must be removed (deleted) before the processing can begin. Other
        systems may allow for appending or updating of a resource (typical with
        database tables).
      </para>

      <para>When creating a new
        <classname>Tap</classname>
        instance, a
        <classname>SinkMode</classname>
        may be provided so that the Tap will
        know how to handle any existing resources. Note that not all Taps
        support all
        <classname>SinkMode</classname>
        values - for example, Hadoop
        does not support appends (updates) from a MapReduce job.
      </para>

      <para>The available SinkModes are:</para>

      <variablelist>
        <varlistentry>
          <term>
            <classname>SinkMode.KEEP</classname>
          </term>

          <listitem>
            <para>This is the default behavior. If the resource exists,
              attempting to write over it will fail.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <classname>SinkMode.REPLACE</classname>
          </term>

          <listitem>
            <para>This allows Cascading to delete the file immediately after
              the Flow is started.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <classname>SinkMode.UPDATE</classname>
          </term>

          <listitem>
            <para>Allows for new tap types that can update or append - for
              example, to update or add records in a database. Each tap may
              implement this functionality in its own way. Cascading recognizes
              this update mode, and if a resource exists, will not fail or
              attempt to delete it.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para linkend="skipping-flows">Note that Cascading itself only uses
        these labels internally to know when to automatically call
        <methodname>deleteResource()</methodname>
        on the
        <classname>Tap</classname>
        or to leave the Tap alone. It is up the the
        <classname>Tap</classname>
        implementation to actually perform a write or
        update when processing starts. Thus, when
        <methodname>start()</methodname>
        or
        <methodname>complete()</methodname>
        is called on a<classname>Flow</classname>, any sink
        <classname>Tap</classname>
        labeled
        <classname>SinkMode.REPLACE</classname>
        will have its
        <methodname>deleteResource()</methodname>
        method called.
      </para>

      <para linkend="skipping-flows">Conversely, if a
        <classname>Flow</classname>
        is in a
        <classname>Cascade</classname>
        and
        the
        <classname>Tap</classname>
        is set to
        <classname>SinkMode.KEEP</classname>
        or
        <classname>SinkMode.REPLACE</classname>,
        <methodname>deleteResource()</methodname>
        will be called if and only if
        the sink is stale (i.e., older than the source). This allows a
        <classname>Cascade</classname>
        to behave like a "make" or "ant" build
        file, only running Flows that should be run. For more information, see
        <xref linkend="skipping-flows"/>.
      </para>

      <para>It's also important to understand how Hadoop deals with
        directories. By default, Hadoop cannot source data from directories with
        nested sub-directories, and it cannot write to directories that already
        exist. However, the good news is that you can simply point the
        <classname>Hfs</classname>
        tap to a directory of data files, and they
        are all used as input - there's no need to enumerate each individual
        file into a<classname>MultiSourceTap</classname>. If there are nested
        directories, use<classname>GlobHfs</classname>.
      </para>
    </section>

    <section>
      <title xreflabel="Field Algebra" xml:id="field-algebra">Fields
        Sets
      </title>

      <para>Cascading applications can perform complex manipulation or "field
        algebra" on the fields stored in tuples, using<emphasis
          role="italic">Fields sets</emphasis>, a feature of the
        <classname>Fields</classname>
        class that provides a sort of wildcard
        tool for referencing sets of field values.
      </para>

      <para>These predefined Fields sets are constant values on the
        <classname>Fields</classname>
        class. They can be used in many places
        where the
        <classname>Fields</classname>
        class is expected. They are:
        <variablelist>
          <varlistentry>
            <term>Fields.ALL</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.ALL</classname>
                constant is a wildcard that represents all the current available
                fields.
              </para>

              <xi:include href="algebra-all.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.RESULTS</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.RESULTS</classname>
                constant is used to represent the field names of the current
                operations return values. This Fields set may only be used as an
                output selector on a pipe, causing the pipe to output a tuple
                containing the operation results.
              </para>

              <xi:include href="algebra-results.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.REPLACE</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.REPLACE</classname>
                constant is used as an output selector to inline-replace values
                in the incoming tuple with the results of an operation. This
                convenient Fields set allows operations to overwrite the value
                stored in the specified field. The current operation must either
                specify the identical argument selector field names used by the
                pipe, or use the
                <classname>ARGS</classname>
                Fields set.
              </para>

              <xi:include href="algebra-replace.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.SWAP</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.SWAP</classname>
                constant is used as an output selector to swap the operation
                arguments with its results. Neither the argument and result
                field names, nor the size, need to be the same. This is useful
                for when the operation arguments are no longer necessary and the
                result Fields and values should be appended to the remainder of
                the input field names and Tuple.
              </para>

              <xi:include href="algebra-swap.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.ARGS</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.ARGS</classname>
                constant is used to let a given operation inherit the field
                names of its argument Tuple. This Fields set is a convenience
                and is typically used when the Pipe output selector is
                <classname>RESULTS</classname>
                or
                <classname>REPLACE</classname>. It is specifically used by the
                Identity Function when coercing values from Strings to primitive
                types.
              </para>

              <xi:include href="algebra-replace.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.GROUP</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.GROUP</classname>
                constant represents all the fields used as grouping key in the
                most recent grouping. If no previous grouping exists in the pipe
                assembly,
                <classname>GROUP</classname>
                represents all the
                current field names.
              </para>

              <xi:include href="algebra-group.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.VALUES</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.VALUES</classname>
                constant represents all the fields not used as grouping fields
                in a previous Group. That is, if you have fields "a", "b", and
                "c", and group on "a",
                <classname>Fields.VALUES</classname>
                will
                resolve to "b" and "c".
              </para>

              <xi:include href="algebra-values.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.UNKNOWN</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.UNKNOWN</classname>
                constant is used when Fields must be declared, but it's not
                known how many fields or what their names are. This allows for
                processing tuples of arbitrary length from an input source or
                some operation. Use this Fields set with caution.
              </para>

              <xi:include href="algebra-unknown.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Fields.NONE</term>

            <listitem>
              <para>The
                <classname>cascading.tuple.Fields.NONE</classname>
                constant is used to specify no fields. Typically used as an
                argument selector for Operations that do not process any Tuples,
                like<classname>cascading.operation.Insert</classname>.
              </para>

              <xi:include href="algebra-none.xml"/>
            </listitem>
          </varlistentry>
        </variablelist>
        The chart below shows common ways to merge input and
        result fields for the desired output fields. A few minutes with this
        chart may help clarify the discussion of fields, tuples, and pipes. Also
        see
        <xref linkend="each-every"/>
        for details on the different columns
        and their relationships to the
        <classname>Each</classname>
        and
        <classname>Every</classname>
        pipes and Functions, Aggregators, and
        Buffers.
      </para>

      <mediaobject xreflabel="Operations and Field-processing"
                   xml:id="field-processing">
        <imageobject role="fo">
          <imagedata align="center" contentwidth="7in"
                     fileref="images/field-algebra.svg"/>
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" contentwidth="7in"
                     fileref="images/field-algebra.png"/>
        </imageobject>
      </mediaobject>
    </section>

    <section>
      <title xreflabel="Flows" xml:id="flows">Flows</title>

      <para>When pipe assemblies are bound to source and sink taps, a
        <classname>Flow</classname>
        is created. Flows are executable in the
        sense that, once they are created, they can be started and will execute
        on the specified platform. If the Hadoop platform is specified, the Flow
        will execute on a Hadoop cluster.
      </para>

      <para>A Flow is essentially a data processing pipeline that reads data
        from sources, processes the data as defined by the pipe assembly, and
        writes data to the sinks. Input source data does not need to exist at
        the time the Flow is created, but it must exist by the time the Flow is
        executed (unless it is executed as part of a Cascade - see
        <xref
          linkend="cascades"/>
        for more on this).
      </para>

      <para>The most common pattern is to create a Flow from an existing pipe
        assembly. But there are cases where a MapReduce job (if running on
        Hadoop) has already been created, and it makes sense to encapsulate it
        in a Flow class so that it may participate in a
        <classname>Cascade</classname>
        and be scheduled with other
        <classname>Flow</classname>
        instances. Alternatively, via the
        <link
          xlink:href="http://github.com/cwensel/riffle">Riffle
        </link>
        annotations, third-party applications can participate in a
        <classname>Cascade</classname>, and complex algorithms that result in
        iterative Flow executions can be encapsulated as a single Flow. All
        patterns are covered here.
      </para>

      <section>
        <title>Creating Flows from Pipe Assemblies</title>

        <example>
          <title>Creating a new Flow</title>

          <xi:include href="simple-flow.xml"/>
        </example>

        <para>To create a Flow, it must be planned though one of the
          FlowConnector subclass objects. In Cascading, each platform (i.e.,
          local and Hadoop) has its own connectors. The
          <code>connect()</code>
          method is used to create new Flow instances based on a set of sink
          taps, source taps, and a pipe assembly. Above is a trivial example
          that uses the Hadoop mode connector.
        </para>

        <example>
          <title>Binding taps in a Flow</title>

          <xi:include href="complex-flow.xml"/>
        </example>

        <para>The example above expands on our previous pipe assembly example
          by creating multiple source and sink taps and planning a Flow. Note
          there are two branches in the pipe assembly - one named "lhs" and the
          other named "rhs". Internally Cascading uses those names to bind the
          source taps to the pipe assembly. New in 2.0, a FlowDef can be created
          to manage the names and taps that must be passed to a
          FlowConnector.
        </para>
      </section>

      <section>
        <title xreflabel="Configuring Flows"
               xml:id="configuring-flows">Configuring Flows
        </title>

        <para>The FlowConnector constructor accepts the
          <classname>java.util.Property</classname>
          object so that default
          Cascading and any platform-specific properties can be passed down
          through the planner to the platform at runtime. In the case of Hadoop,
          any relevant Hadoop
          <code>hadoop-default.xml</code>
          properties may be
          added. For instance, it's very common to add
          <code>mapred.map.tasks.speculative.execution</code>,
          <code>mapred.reduce.tasks.speculative.execution</code>, or
          <code>mapred.child.java.opts</code>.
        </para>

        <para>One of the two properties that must always be set for production
          applications is the application Jar class or Jar path.
        </para>

        <example>
          <title>Configuring the Application Jar</title>

          <xi:include href="flow-properties.xml"/>
        </example>

        <para>More information on packaging production applications can be
          found in<xref linkend="executing-processes"/>.
        </para>

        <para>Note the pattern of using a static property-setter method
          (<classname>cascading.property.AppProps.setApplicationJarPath</classname>).
        </para>

        <para>Since the
          <classname>FlowConnector</classname>
          can be reused,
          any properties passed on the constructor will be handed to all the
          Flows it is used to create. If Flows need to be created with different
          default properties, a new FlowConnector will need to be instantiated
          with those properties, or properties will need to be set on a given
          <classname>Pipe</classname>
          or
          <classname>Tap</classname>
          instance
          directly - via the
          <methodname>getConfigDef()</methodname>
          or
          <methodname>getStepConfigDef()</methodname>
          methods.
        </para>
      </section>

      <section>
        <title xreflabel="Skipping Flows" xml:id="skipping-flows">Skipping
          Flows
        </title>

        <para>When a
          <classname>Flow</classname>
          participates in a
          <classname>Cascade</classname>, the
          <classname>Flow.isSkipFlow()</classname>
          method is consulted before
          calling
          <classname>Flow.start()</classname>
          on the flow. The result is
          based on the Flow's<emphasis role="italic">skip strategy</emphasis>.
          By default,
          <methodname>isSkipFlow()</methodname>
          returns true if any
          of the sinks are stale - i.e., the sinks don't exist or the resources
          are older than the sources. However, the strategy can be changed via
          the
          <classname>Flow.setFlowSkipStrategy()</classname>
          and
          <classname>Cascade.setFlowSkipStrategy()</classname>
          method, which can
          be called before or after a particular
          <classname>Flow</classname>
          instance has been created.
        </para>

        <para>Cascading provides a choice of two standard skip
          strategies:
        </para>

        <variablelist>
          <varlistentry>
            <term>FlowSkipIfSinkNotStale</term>

            <listitem>
              <para>This strategy -
                <classname>cascading.flow.FlowSkipIfSinkNotStale</classname>
                -
                is the default. Sinks are treated as stale if they don't exist
                or the sink resources are older than the sources. If the
                SinkMode for the sink tap is REPLACE, then the tap is treated as
                stale.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>FlowSkipIfSinkExists</term>

            <listitem>
              <para>The
                <classname>cascading.flow.FlowSkipIfSinkExists</classname>
                strategy skips the Flow if the sink tap exists, regardless of
                age. If the
                <classname>SinkMode</classname>
                for the sink tap is
                <code>REPLACE</code>, then the tap is treated as stale.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Additionally, you can implement custom skip strategies by using
          the interface
          <classname>cascading.flow.FlowSkipStrategy</classname>.
        </para>

        <para>Note that
          <classname>Flow.start()</classname>
          does not consult
          the
          <methodname>isSkipFlow()</methodname>
          method, and consequently
          always tries to start the Flow if called. It is up to the user code to
          call
          <classname>isSkipFlow()</classname>
          to determine whether the
          current strategy indicates that the Flow should be skipped.
        </para>
      </section>

      <section>
        <title>Creating Flows from a JobConf</title>

        <para>If a MapReduce job already exists and needs to be managed by a
          Cascade, then the
          <classname>cascading.flow.hadoop.MapReduceFlow</classname>
          class
          should be used. To do this, after creating a Hadoop
          <classname>JobConf</classname>
          instance simply pass it into the
          <classname>MapReduceFlow</classname>
          constructor. The resulting
          <classname>Flow</classname>
          instance can be used like any other
          Flow.
        </para>
      </section>

      <section>
        <title>Creating Custom Flows</title>

        <para>Any custom Class can be treated as a Flow if given the correct
          <link xlink:href="http://github.com/cwensel/riffle">Riffle</link>
          annotations. Riffle is a set of Java annotations that identify
          specific methods on a class as providing specific life-cycle and
          dependency functionality. For more information, see the Riffle
          documentation and examples. To use with Cascading, a Riffle-annotated
          instance must be passed to the
          <classname>cascading.flow.hadoop.ProcessFlow</classname>
          constructor
          method. The resulting
          <classname>ProcessFlow</classname>
          instance can
          be used like any other Flow instance.
        </para>

        <para>Since many algorithms need to perform multiple passes over a
          given data set, a Riffle-annotated Class can be written that
          internally creates Cascading Flows and executes them until no more
          passes are needed. This is like nesting Flows or Cascades in a parent
          Flow, which in turn can participate in a Cascade.
        </para>
      </section>
    </section>

    <section>
      <title xreflabel="Cascades" xml:id="cascades">Cascades</title>

      <mediaobject>
        <imageobject role="fo">
          <imagedata contentwidth="2in" fileref="images/cascade.svg"/>
        </imageobject>

        <imageobject role="html">
          <imagedata contentwidth="2in" fileref="images/cascade.png"/>
        </imageobject>
      </mediaobject>

      <para>A Cascade allows multiple Flow instances to be executed as a
        single logical unit. If there are dependencies between the Flows, they
        are executed in the correct order. Further, Cascades act like Ant builds
        or Unix make files - that is, a Cascade only executes Flows that have
        stale sinks (i.e., output data that is older than the input data). For
        more on this, see<xref linkend="skipping-flows"/>.
      </para>

      <example>
        <title>Creating a new Cascade</title>

        <xi:include href="simple-cascade.xml"/>
      </example>

      <para>When passing Flows to the CascadeConnector, order is not
        important. The CascadeConnector automatically identifies the
        dependencies between the given Flows and creates a scheduler that starts
        each Flow as its data sources become available. If two or more Flow
        instances have no interdependencies, they are submitted together so that
        they can execute in parallel.
      </para>

      <para>For more information, see the section on<xref
        linkend="cascade-scheduler"/>.
      </para>

      <para>If an instance of
        <classname>cascading.flow.FlowSkipStrategy</classname>
        is given to a
        <classname>Cascade</classname>
        instance (via the
        <classname>Cascade.setFlowSkipStrategy()</classname>
        method), it is
        consulted for every Flow instance managed by that Cascade, and all skip
        strategies on those Flow instances are ignored. For more information on
        skip strategies, see<xref linkend="skipping-flows"/>.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title xreflabel="Executing Processes"
             xml:id="executing-processes">Executing Processes on Hadoop
      </title>
    </info>

    <section>
      <title>Introduction</title>

      <para>This section covers some of the operational mechanics of running
        an application that uses Cascading with the Hadoop platform, including
        building the application jar file and configuring the operating
        mode.
      </para>

      <para>To use the
        <classname>HadoopFlowConnector</classname>
        (i.e., to
        run in Hadoop mode), Cascading requires that Apache Hadoop be installed
        and correctly configured. Hadoop is an Open Source Apache project,
        freely available for download from the Hadoop website,<link
          xlink:href="http://hadoop.apache.org/core/">http://hadoop.apache.org/core/</link>.
      </para>
    </section>

    <section>
      <title xreflabel="Building" xml:id="building">Building</title>

      <para>Cascading ships with several jars and dependencies in the download
        archive. Alternatively, Cascading is available over Maven and Ivy
        through the Conjars repository, along with a number of other
        Cascading-related projects. See
        <link
          xlink:href="http://conjars.org/">http://conjars.org
        </link>
        for more
        information.
      </para>

      <para>The core Cascading artifacts include the following:</para>

      <variablelist>
        <varlistentry>
          <term>cascading-core-2.0.x.jar</term>

          <listitem>
            <para>This jar contains the Cascading Core class files. It should
              be packaged with
              <filename>lib/*.jar</filename>
              when using
              Hadoop.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cascading-local-2.0.x.jar</term>

          <listitem>
            <para>This jar contains the Cascading local mode class files. It
              is not needed when using Hadoop.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cascading-hadoop-2.0.x.jar</term>

          <listitem>
            <para>This jar contains the Cascading Hadoop specific
              dependencies. It should be packaged with
              <filename>lib/*.jar</filename>
              when using Hadoop.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cascading-xml-1.2.x.jar</term>

          <listitem>
            <para>This jar contains Cascading XML module class files and is
              optional. It should be packaged with
              <filename>lib/xml/*.jar</filename>
              when using Hadoop.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>cascading-test-1.2.x.jar</term>

          <listitem>
            <para>This jar contains Cascading unit tests. If writing custom
              modules for cascading, it may be helpful to subclass
              <classname>cascading.CascadingTestCase</classname>.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Cascading works with either of the Hadoop processing modes - the
        default local standalone mode and the distributed cluster mode. As
        specified in the Hadoop documentation, running in cluster mode requires
        the creation of a Hadoop job jar that includes the Cascading jars, plus
        any needed third-party jars, in its
        <filename>lib</filename>
        directory.
        This is true regardless of whether they are Cascading Hadoop-mode
        applications or raw Hadoop MapReduce applications.
      </para>
    </section>

    <section>
      <title>Configuring</title>

      <para>During runtime, Hadoop must be told which application jar file
        should be pushed to the cluster. Typically, this is done via the Hadoop
        API
        <classname>JobConf</classname>
        object.
      </para>

      <para>Cascading offers a shorthand for configuring this parameter,
        demonstrated here:
      </para>

      <xi:include href="flow-properties.xml"/>

      <para>Above we see two ways to set the same property - via the
        <methodname>setApplicationJarClass()</methodname>
        method, and via the
        <methodname>setApplicationJarPath()</methodname>
        method. One is based on
        a Class name, and the other is based on a literal path.
      </para>

      <para>The first method takes a Class object that owns the "main"
        function for this application. The assumption here is that
        <code>Main.class</code>
        is not located in a Java Jar that is stored in
        the
        <filename>lib</filename>
        folder of the application Jar. If it is,
        that Jar is pushed to the cluster, not the parent application
        jar.
      </para>

      <para>The second method simply sets the path to the parent Class as a
        property.
      </para>

      <para>In your application, only one of these methods needs to be called,
        but one of them must be called to properly configure Hadoop.
      </para>

      <example>
        <title>Configuring the Application Jar with a JobConf</title>

        <xi:include href="flow-jobconf.xml"/>
      </example>

      <para>Above we are starting with an existing Hadoop
        <classname>JobConf</classname>
        instance
        and building a Properties object with it as the default.
      </para>

    </section>

    <section>
      <title>Executing</title>

      <para>Running a Cascading application is the same as running any Hadoop
        application. After packaging your application into a single jar (see
        <xref linkend="building"/>), you must use
        <filename>bin/hadoop</filename>
        to submit the application to the
        cluster.
      </para>

      <para>For example, to execute an application stuffed into
        <filename>your-application.jar</filename>, call the Hadoop shell
        script:
      </para>

      <example>
        <title>Running a Cascading Application</title>

        <para>
          <programlisting>$HADOOP_HOME/bin/hadoop jar your-application.jar [some params]</programlisting>
        </para>
      </example>

      <para>If the configuration scripts in
        <envar>$HADOOP_CONF_DIR</envar>
        are configured to use a cluster, the Jar is pushed into the cluster for
        execution.
      </para>

      <para>Cascading does not rely on any environment variables like
        <envar>$HADOOP_HOME</envar>
        or<envar>$HADOOP_CONF_DIR</envar>, only
        <filename>bin/hadoop</filename>
        does.
      </para>

      <para>It should be noted that even though
        <filename>your-application.jar</filename>
        is passed on the command line
        to<filename>bin/hadoop</filename>, this in no way configures Hadoop to
        push this jar into the cluster. You must still call one of the property
        setters mentioned above to set the proper path to the application jar.
        If misconfigured, it's likely that one of the internal libraries (found
        in the lib folder) will be pushed to the cluster instead, and "Class Not
        Found" exceptions will be thrown.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Using and Developing Operations</title>
    </info>

    <section>
      <title>Introduction</title>

      <para>So far we've talked about setting up sources and sinks, shaping
        the data streams, referencing the data fields, and so on. Within this
        Pipe framework, Operations are used to act upon the data - e.g., alter
        it, filter it, analyze it, or transform it. You can use the standard
        Operations in the Cascading library to create powerful and robust
        applications by combining them in chains (much like Unix operations such
        as<command>sed</command>,<command>grep</command>,
        <command>sort</command>,<command>uniq</command>, and
        <command>awk</command>). And if you want to go further, it's also very
        simple to develop custom Operations in Cascading.
      </para>

      <para>There are four kinds of Operations:
        <classname>Function</classname>,<classname>Filter</classname>,
        <classname>Aggregator</classname>, and
        <classname>Buffer</classname>.
      </para>

      <mediaobject>
        <imageobject role="fo">
          <imagedata align="center" contentwidth="3in"
                     fileref="images/operations.svg"/>
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" contentwidth="3in"
                     fileref="images/operations.png"/>
        </imageobject>
      </mediaobject>

      <para>Operations typically require an input argument Tuple to act on.
        And all Operations can return zero or more Tuple object results - except
        <classname>Filter</classname>, which simply returns a Boolean indicating
        whether to discard the current Tuple. A<classname>Function</classname>,
        for instance, can parse a string passed by an argument Tuple and return
        a new Tuple for every value parsed (i.e., one Tuple for each "word"), or
        it may create a single Tuple with every parsed value included as an
        element in one Tuple object (e.g., one Tuple with "first-name" and
        "last-name" fields).
      </para>

      <para>In theory, a
        <classname>Function</classname>
        can be used as a
        <classname>Filter</classname>
        by not emitting a Tuple result. However,
        the
        <classname>Filter</classname>
        type is optimized for filtering, and
        can be combined with logical Operations such as
        <classname>Not</classname>,<classname>And</classname>,
        <classname>Or</classname>, etc.
      </para>

      <para>During runtime, Operations actually receive arguments as one or
        more instances of the
        <classname>TupleEntry</classname>
        object. The
        TupleEntry object holds the current
        <classname>Tuple</classname>
        and a
        <classname>Fields</classname>
        object that defines field names for
        positions within the Tuple.
      </para>

      <para>Except for<classname>Filter</classname>, all Operations must
        declare result Fields, and if the actual output does not match the
        declaration, the process will fail. For example, consider a
        <classname>Function</classname>
        written to parse words out of a String
        and return a new Tuple for each word. If it declares that its intended
        output is a Tuple with a single field named "word", and then returns
        more values in the Tuple beyond that single "word", processing will
        halt. However, Operations designed to return arbitrary numbers of values
        in a result Tuple may declare<code>Fields.UNKNOWN</code>.
      </para>

      <para>The Cascading planner always attempts to "fail fast" where
        possible by checking the field name dependencies between Pipes and
        Operations, but there may be some cases the planner can't account
        for.
      </para>

      <para>All Operations must be wrapped by either an
        <classname>Each</classname>
        or an
        <classname>Every</classname>
        pipe
        instance. The pipe is responsible for passing in an argument Tuple and
        accepting the resulting output Tuple.
      </para>

      <para>Operations by default are assumed by the Cascading planner to be
        "safe". A safe Operation is idempotent; it can safely execute multiple
        times on the exact same record or Tuple; it has no side-effects. If a
        custom Operation is not idempotent, the method
        <code>isSafe()</code>
        must return<code>false</code>. This value influences how the Cascading
        planner renders the Flow under certain circumstances.
      </para>
    </section>

    <section>
      <title>Functions</title>

      <para>A
        <classname>Function</classname>
        expects a stream of individual
        argument Tuples, and returns zero or more result Tuples for each of
        them. Like a<classname>Filter</classname>, a
        <classname>Function</classname>
        is used with an
        <classname>Each</classname>
        pipe, which may follow any pipe type.
      </para>

      <para>To create a custom<classname>Function</classname>, subclass the
        class
        <code>cascading.operation.BaseOperation</code>
        and implement the
        interface<code>cascading.operation.Function</code>. Since the
        <code>BaseOperation</code>
        has been subclassed, the
        <code>operate</code>
        method, as defined on the
        <code>Function</code>
        interface, is the only
        method that must be implemented.
      </para>

      <example>
        <title>Custom Function</title>

        <xi:include href="custom-function.xml"/>
      </example>

      <para>Whenever possible, functions should declare both the number of
        argument values they expect and the field names of the Tuple they
        return. However, these declarations are optional, as explained
        below.
      </para>

      <para>For input, functions must accept one or more values in a Tuple as
        arguments. If not specified, the default is to accept any number of
        values (<code>Operation.ANY</code>). Cascading verifies during planning
        that the number of arguments selected matches the number of arguments
        expected.
      </para>

      <para>For output, it's a good practice to declare the field names that a
        function returns. If not specified, the default is
        <code>Fields.UNKNOWN</code>, meaning that an unknown number of fields
        are returned in each Tuple.
      </para>

      <para>Both declarations - the number of input arguments and declared
        result fields - must be done on the constructor, either by passing
        default values to the
        <code>super</code>
        constructor, or by accepting
        the values from the user via a constructor implementation.
      </para>

      <example>
        <title>Add Values Function</title>

        <xi:include href="sum-function.xml"/>
      </example>

      <para>The example above implements a
        <classname>Function</classname>
        that accepts two values in the argument Tuple, adds them together, and
        returns the result in a new Tuple.
      </para>

      <para>The first constructor above assumes a default field name for the
        field that this
        <classname>Function</classname>
        returns. In practice,
        it's good to give the user the option of overriding the declared field
        names, allowing them to prevent possible field name collisions that
        might cause the planner to fail.
      </para>

      <para>This line is especially important:
        <programlisting>int sum = arguments.getInteger( 0 ) +
          arguments.getInteger( 1 );
        </programlisting>
        Note that ordinal numbers,
        not field names, are used here to get argument values. If field names
        had been used, the AddValuesFunction would have been coupled to the
        incoming stream.
      </para>

      <example>
        <title>Add Values Function and Context</title>

        <xi:include href="efficient-sum-function.xml"/>
      </example>

      <para>This example, a minor variation on the previous one, introduces
        the use of a "context" object and
        <methodname>prepare()</methodname>
        and
        <methodname>cleanup()</methodname>
        methods.
      </para>

      <para>All Operations allow for a context object, simply a user-defined
        object that holds state between calls to the
        <methodname>operate()</methodname>
        method. This allows for a given
        instance of the Operation to be thread safe on a platform that may use
        multiple threads of execution versus multiple processes. It also allows
        deferring initialization of complex resources until the Operation is
        engaged.
      </para>

      <para>The
        <methodname>prepare()</methodname>
        and
        <methodname>cleanup()</methodname>
        methods are invoked once per thread
        of execution, and in the case of the Hadoop platform, only on the
        cluster side, never on the client.
      </para>

      <para>In the above example, a
        <classname>Tuple</classname>
        is used as
        the context; a more complex type isn't necessary. Also note that the
        Tuple isn't storing state, but is re-used to reduce the number of new
        Object instances created. In Cascading, it is perfectly safe to output
        the same Tuple instance from<methodname>operate()</methodname>. The
        method
        <code>functionCall.getOutputCollector().add( result )</code>
        will
        not return until the result
        <classname>Tuple</classname>
        has been
        processed or persisted downstream.
      </para>
    </section>

    <section>
      <title>Filter</title>

      <para>A
        <classname>Filter</classname>
        expects a stream of individual
        argument Tuples and returns a Boolean value for each one, stating
        whether it should be discarded. Like a<classname>Function</classname>, a
        <classname>Filter</classname>
        is used with an
        <classname>Each</classname>
        pipe, which may follow any pipe type.
      </para>

      <para>To create a custom<classname>Filter</classname>, subclass the
        class
        <code>cascading.operation.BaseOperation</code>
        and implement the
        interface<code>cascading.operation.Filter</code>. Because
        <code>BaseOperation</code>
        has been subclassed, the
        <code>isRemove</code>
        method, as defined on the
        <code>Filter</code>
        interface, is the only method that must be implemented.
      </para>

      <example>
        <title>Custom Filter</title>

        <xi:include href="custom-filter.xml"/>
      </example>

      <para>Filters must accept one or more values in a Tuple as arguments,
        and should declare the number of argument values they expect. If not
        specified, the default is to accept any number of values
        (<code>Operation.ANY</code>). Cascading verifies during planning that
        the number of arguments selected matches the number of arguments
        expected.
      </para>

      <para>The number of arguments declaration must be done on the
        constructor, either by passing a default value to the
        <code>super</code>
        constructor, or by accepting the value from the user via a constructor
        implementation.
      </para>

      <example>
        <title>String Length Filter</title>

        <xi:include href="stringlength-filter.xml"/>
      </example>

      <para>The example above implements a
        <classname>Filter</classname>
        that
        accepts two arguments and filters out the current Tuple if the first
        argument, String length, is greater than the integer value of the second
        argument.
      </para>
    </section>

    <section>
      <title>Aggregator</title>

      <para>An
        <classname>Aggregator</classname>
        expects a stream of tuple
        groups (the output of a
        <classname>GroupBy</classname>
        or
        <classname>CoGroup</classname>
        pipe), and returns zero or more result
        tuples for every group. An
        <classname>Aggregator</classname>
        may only be
        used with an
        <classname>Every</classname>
        pipe - which may follow a
        <classname>GroupBy</classname>, a<classname>CoGroup</classname>, or
        another
        <classname>Every</classname>
        pipe, but not an
        <classname>Each</classname>.
      </para>

      <para>To create a custom<classname>Aggregator</classname>, subclass the
        class
        <code>cascading.operation.BaseOperation</code>
        and implement the
        interface<code>cascading.operation.Aggregator</code>. Because
        <code>BaseOperation</code>
        has been subclassed, the<code>start</code>,
        <code>aggregate</code>, and
        <code>complete</code>
        methods, as defined on
        the
        <code>Aggregator</code>
        interface, are the only methods that must be
        implemented.
      </para>

      <example>
        <title>Custom Aggregator</title>

        <xi:include href="custom-aggregator.xml"/>
      </example>

      <para>Whenever possible, Aggregators should declare both the number of
        argument values they expect and the field names of the Tuple they
        return. However, these declarations are optional, as explained
        below.
      </para>

      <para>For input, Aggregators must accept one or more values in a Tuple
        as arguments. If not specified, the default is to accept any number of
        values (<code>Operation.ANY</code>). Cascading verifies during planning
        that the number of arguments selected is the same as the number of
        arguments expected.
      </para>

      <para>For output, it's good practice for Aggregators to declare the
        field names they return. If not specified, the default is
        <code>Fields.UNKNOWN</code>, meaning that an unknown number of fields
        are returned in each Tuple.
      </para>

      <para>Both declarations - the number of input arguments and declared
        result fields - must be done on the constructor, either by passing
        default values to the
        <code>super</code>
        constructor, or by accepting
        the values from the user via a constructor implementation.
      </para>

      <example>
        <title>Add Tuples Aggregator</title>

        <xi:include href="sum-aggregator.xml"/>
      </example>

      <para>The example above implements an
        <classname>Aggregator</classname>
        that accepts a value in the argument Tuple, adds all the argument tuples
        in the current grouping, and returns the result as a new Tuple.
      </para>

      <para>The first constructor above assumes a default field name that this
        <classname>Aggregator</classname>
        returns. In practice, it's good to
        give the user the option of overriding the declared field names,
        allowing them to prevent possible field name collisions that might cause
        the planner to fail.
      </para>

      <para>There are several constraints on the use of Aggregators that may
        not be self-evident. These are detailed in the Javadoc
      </para>
    </section>

    <section>
      <title>Buffer</title>

      <para>A
        <classname>Buffer</classname>
        expects set of argument tuples in
        the same grouping, and may return zero or more result tuples.
      </para>

      <para>A
        <classname>Buffer</classname>
        is very similar to an
        <classname>Aggregator</classname>, except that it receives the current
        Grouping Tuple, and an iterator of all the arguments it expects, for
        every value Tuple in the current grouping - all on the same method call.
        This is very similar to the typical Reducer interface in MapReduce, and
        is best used for operations that need visibility to the previous and
        next elements in the stream - such as smoothing a series of time-stamps
        where there are missing values.
      </para>

      <para>A
        <classname>Buffer</classname>
        may only be used with an
        <classname>Every</classname>
        pipe, and it may only follow a
        <classname>GroupBy</classname>
        or
        <classname>CoGroup</classname>
        pipe
        type.
      </para>

      <para>To create a custom<classname>Buffer</classname>, subclass the
        class
        <code>cascading.operation.BaseOperation</code>
        and implement the
        interface<code>cascading.operation.Buffer</code>. Because
        <code>BaseOperation</code>
        has been subclassed, the
        <code>operate</code>
        method, as defined on the
        <code>Buffer</code>
        interface, is the only
        method that must be implemented.
      </para>

      <example>
        <title>Custom Buffer</title>

        <xi:include href="custom-buffer.xml"/>
      </example>

      <para>Buffers should declare both the number of argument values they
        expect and the field names of the Tuple they return.
      </para>

      <para>For input, Buffers must accept one or more values in a Tuple as
        arguments. If not specified, the default is to accept any number of
        values (Operation.ANY). During the planning phase, Cascading verifies
        that the number of arguments selected is the same as the number of
        arguments expected.
      </para>

      <para>For output, it's good practice for Buffers to declare the field
        names they return. If not specified, the default is
        <code>Fields.UNKNOWN</code>, meaning that an unknown number of fields
        are returned in each Tuple.
      </para>

      <para>Both declarations - the number of input arguments and declared
        result fields - must be done on the constructor, either by passing
        default values to the
        <code>super</code>
        constructor, or by accepting
        the values from the user via a constructor implementation.
      </para>

      <example>
        <title>Average Buffer</title>

        <xi:include href="average-buffer.xml"/>
      </example>

      <para>The example above implements a buffer that accepts a value in the
        argument Tuple, adds all these argument tuples in the current grouping,
        and returns the result divided by the number of argument tuples counted
        in a new Tuple.
      </para>

      <para>The first constructor above assumes a default field name for the
        field that this
        <classname>Buffer</classname>
        returns. In practice, it's
        good to give the user the option of overriding the declared field names,
        allowing them to prevent possible field name collisions that might cause
        the planner to fail
      </para>

      <para>Note that this example is somewhat artificial. In actual practice,
        an
        <classname>Aggregator</classname>
        would be a better way to compute
        averages for an entire dataset. A
        <classname>Buffer</classname>
        is
        better suited for calculating running averages across very large spans,
        for example.
      </para>

      <para>There are several constraints on the use of Buffers that may not
        be self-evident. These are detailed in the Javadoc.
      </para>

      <para>As with the
        <classname>Function</classname>
        example above, a
        <classname>Buffer</classname>
        may define a custom context object and
        implement the
        <methodname>prepare()</methodname>
        and
        <methodname>cleanup()</methodname>
        methods to maintain state, or re-use
        outgoing
        <classname>Tuple</classname>
        instances for efficiency.
      </para>
    </section>

    <section>
      <title>Operation and BaseOperation</title>

      <para>In all of the above sections, the
        <classname>cascading.operation.BaseOperation</classname>
        class was
        subclassed. This class is an implementation of the
        <classname>cascading.operation.Operation</classname>
        interface, and
        provides a few default method implementations. It is not strictly
        required to extend
        <classname>BaseOperation</classname>
        when
        implementing this interface, but it is very convenient to do so.
      </para>

      <para>When developing custom operations, the developer may need to
        initialize and destroy a resource. For example, when doing pattern
        matching, you might need to initialize a
        <classname>java.util.regex.Matcher</classname>
        and use it in a
        thread-safe way. Or you might need to open, and eventually close, a
        remote connection. But for performance reasons, the operation should not
        create or destroy the connection for each Tuple or every Tuple group
        that passes through.
      </para>

      <para>For this reason, the interface
        <interfacename>Operation</interfacename>
        declares two methods:
        <methodname>prepare()</methodname>
        and
        <methodname>cleanup()</methodname>. In the case of Hadoop and MapReduce,
        the
        <methodname>prepare()</methodname>
        and
        <methodname>cleanup()</methodname>
        methods are called once per Map or
        Reduce task. The
        <methodname>prepare()</methodname>
        method is called
        before any argument Tuple is passed in, and the
        <methodname>cleanup()</methodname>
        method is called after all Tuple
        arguments have been operated on. Within each of these methods, the
        developer can initialize a "context" object that can hold an open socket
        connection or
        <classname>Matcher</classname>
        instance. This context is
        user defined, and is the same mechanism used by the
        <classname>Aggregator</classname>
        operation - except that the
        <classname>Aggregator</classname>
        is also given the opportunity to
        initialize and destroy its context, via the
        <classname>start()</classname>
        and
        <classname>complete()</classname>
        methods.
      </para>

      <para>Note that if a "context" object is used, its type should be
        declared in the subclass class declaration using the Java Generics
        notation.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title xreflabel="Custom Taps" xml:id="custom-taps">Custom Taps and
        Schemes
      </title>
    </info>

    <section>
      <title>Introduction</title>

      <para>Cascading is designed to be easily configured and enhanced by
        developers. In addition to creating custom Operations, developers can
        create custom
        <classname>Tap</classname>
        and
        <classname>Scheme</classname>
        classes that let applications connect to
        external systems or read/write data to proprietary formats.
      </para>

      <para>A Tap represents something physical, like a file or a database
        table. Accordingly, Tap implementations are responsible for life-cycle
        issues around the resource they represent, such as tests for resource
        existence, or to perform resource deletion (dropping a remote SQL
        table).
      </para>

      <para>A Scheme represents a format or representation - such as a text
        format for a file, the columns in a table, etc. Schemes are used to
        convert between the source data's native format and a
        <classname>cascading.tuple.Tuple</classname>
        instance.
      </para>

      <para>Creating custom taps and schemes can be an involved process. When
        using the Cascading Hadoop mode, it requires some knowledge of Hadoop
        and the Hadoop FileSystem API. If a flow needs to support a new file
        system, passing a fully-qualified URL to the
        <classname>Hfs</classname>
        constructor may be sufficient - the
        <classname>Hfs</classname>
        tap will
        look up a file system based on the URL scheme via the Hadoop FileSystem
        API. If not, a new system is commonly constructed by subclassing the
        <classname>cascading.tap.Hfs</classname>
        class.
      </para>

      <para>Delegating to the Hadoop FileSystem API is not a strict
        requirement. But if not using it, the developer must implement Hadoop
        <classname>org.apache.hadoop.mapred.InputFormat</classname>
        and/or
        <classname>org.apache.hadoop.mapred.OutputFormat</classname>
        classes so
        that Hadoop knows how to split and handle the incoming/outgoing data.
        The custom
        <classname>Scheme</classname>
        is responsible for setting the
        <classname>InputFormat</classname>
        and
        <classname>OutputFormat</classname>
        on the
        <classname>JobConf</classname>, via the
        <methodname>sinkConfInit</methodname>
        and
        <methodname>sourceConfInit</methodname>
        methods.
      </para>

      <para>For examples of how to implement a custom tap and scheme, see the
        <link xlink:href="http://cascading.org/modules.html">Cascading Modules
        </link>
        page.
      </para>
    </section>

    <section>
      <title>Custom Taps</title>

      <para>All custom Tap classes must subclass the
        <classname>cascading.tap.Tap</classname>
        abstract class and implement
        the required methods. The method
        <methodname>getIdentifier()</methodname>
        must return a
        <classname>String</classname>
        that uniquely identifies the resource the
        Tap instance is managing. Any two Tap instances with the same
        fully-qualified identifier value will be considered equal.
      </para>

      <para>Every Tap is presented an opportunity to set any custom properties
        the underlying platform requires, via the methods
        <methodname>sourceConfInit()</methodname>
        (for a Tuple source tap) and
        <methodname>sinkConfInit()</methodname>
        (for a Tuple sink tap). These
        two methods may be called more than once with new configuration objects,
        and should be idempotent.
      </para>

      <para>A Tap is always sourced from the
        <methodname>openForRead()</methodname>
        method via a
        <classname>TupleEntryIterator</classname>
        - i.e.,
        <methodname>openForRead()</methodname>
        is always called in the same
        process that will read the data. It is up to the Tap to return a
        <classname>TupleEntryIterator</classname>
        that will iterate across the
        resource, returning a
        <classname>TupleEntry</classname>
        instance (and
        <classname>Tuple</classname>
        instance) for each "record" in the
        resource.
        <methodname>TupleEntryIterator.close()</methodname>
        is always
        called when no more entries will be read. For more on this topic, see
        <classname>TupleEntrySchemeIterator</classname>
        in the Javadoc.
      </para>

      <para>On some platforms,
        <methodname>openForRead()</methodname>
        is
        called with a pre-instantiated Input type. Typically this Input type
        should be used instead of instantiating a new instance of the
        appropriate type.
      </para>

      <para>In the case of the Hadoop platform, a
        <classname>RecordReader</classname>
        is created by Hadoop and passed to
        the Tap. This
        <classname>RecordReader</classname>
        is already configured
        to read data from the current<classname>InputSplit</classname>.
      </para>

      <para>Similiarly, a Tap is always used to sink data from the
        <methodname>openForWrite()</methodname>
        method via the
        <classname>TupleEntryCollector</classname>. Here again,
        <methodname>openForWrite()</methodname>
        is always called in the process
        in which data will be written. It is up to the Tap to return a
        <classname>TupleEntryCollector</classname>
        that will accept and store
        any number of
        <classname>TupleEntry</classname>
        or
        <classname>Tuple</classname>
        instances for each record that is processed
        or created by a given Flow.
        <methodname>TupleEntryCollector.close()</methodname>
        is always called
        when no more entries will be written. See
        <classname>TupleEntrySchemeCollector</classname>
        in the Javadoc.
      </para>

      <para>Again, on some platforms,
        <methodname>openForWrite()</methodname>
        will be called with a pre-instantiated Output type. Typically this
        Output type should be used instead of instantiating a new instance of
        the appropriate type.
      </para>

      <para>In the case of the Hadoop platform, an
        <classname>OutputCollector</classname>
        is created by Hadoop and passed
        to the Tap. This
        <classname>OutputCollector</classname>
        is already
        configured to to write data to the current resource.
      </para>

      <para>Both the
        <classname>TupleEntrySchemeIterator</classname>
        and
        <classname>TupleEntrySchemeCollector</classname>
        should be used to hold
        any state or resources necessary to communicate with any remote
        services. For example, when connecting to a SQL database, any JDBC
        drivers should be created on the constructor and cleaned up on
        <methodname>close()</methodname>.
      </para>

      <para>Note that the Tap is not responsible for reading or writing data
        to the Input or Output type. This is delegated to the
        <classname>Scheme</classname>
        passed on the constructor of the
        <classname>Tap</classname>. Consequently, the
        <classname>Scheme</classname>
        is responsible for configuring the Input
        and Output types it will be reading and writing.
      </para>
    </section>

    <section>
      <title>Custom Schemes</title>

      <para>All custom Scheme classes must subclass the
        <classname>cascading.scheme.Scheme</classname>
        abstract class and
        implement the required methods.
      </para>

      <para>A
        <classname>Scheme</classname>
        is ultimately responsible for
        sourcing and sinking Tuples of data. Consequently it must know what
        <classname>Fields</classname>
        it presents during sourcing, and what
        <classname>Fields</classname>
        it accepts during sinking. Thus the
        constructors on the base
        <classname>Scheme</classname>
        type must be set
        with the source and sink Fields.
      </para>

      <para>A Scheme is allowed to source different Fields than it sinks. The
        <classname>TextLine</classname>
        <classname>Scheme</classname>
        does just
        this. (The
        <classname>TextDelimited</classname>
        <classname>Scheme</classname>, on the other hand, forces the source and
        sink
        <classname>Fields</classname>
        to be the same.)
      </para>

      <para>The
        <methodname>retrieveSourceFields()</methodname>
        and
        <methodname>retrieveSinkFields()</methodname>
        methods allow a custom
        <classname>Scheme</classname>
        to fetch its source and sink
        <classname>Fields</classname>
        immediately before the planner is invoked
        - for example, from the header of a file, as is the case with
        <classname>TextDelimited</classname>. Also the
        <methodname>presentSourceFields()</methodname>
        and
        <methodname>presentSinkFields()</methodname>
        methods notify the
        <classname>Scheme</classname>
        of the
        <classname>Fields</classname>
        that
        the planner expects the Scheme to handle - for example, to write the
        field names as a header, as is the case with
        <classname>TextDelimited</classname>.
      </para>

      <para>Every
        <classname>Scheme</classname>
        is presented the opportunity
        to set any custom properties the underlying platform requires, via the
        methods
        <methodname>sourceConfInit()</methodname>
        (for a Tuple source tap)
        and
        <methodname>sinkConfInit()</methodname>
        (for a Tuple sink tap).
        These methods may be called more than once with new configuration
        objects, and should be idempotent.
      </para>

      <para>On the Hadoop platform, these methods should be used to configure
        the appropriate
        <classname>org.apache.hadoop.mapred.InputFormat</classname>
        and
        <classname>org.apache.hadoop.mapred.OutputFormat</classname>.
      </para>

      <para>A Scheme is always sourced via the
        <methodname>source()</methodname>
        method, and is always sunk to via the
        <methodname>sink()</methodname>
        method.
      </para>

      <para>Prior to a
        <methodname>source()</methodname>
        or
        <methodname>sink()</methodname>
        call, the
        <methodname>sourcePrepare()</methodname>
        and
        <methodname>sinkPrepare()</methodname>
        methods are called. After all
        values have been read or written, the s
        <methodname>ourceCleanup()</methodname>
        and
        <methodname>sinkCleanup()</methodname>
        methods are called.
      </para>

      <para>The
        <methodname>*Prepare()</methodname>
        methods allow a Scheme to
        initialize any state necessary - for example, to create a new
        <classname>java.util.regex.Matcher</classname>
        instance for use against
        all record reads). Conversely, the
        <methodname>*Cleanup()</methodname>
        methods allow for clearing up any resources.
      </para>

      <para>These methods are always called in the same process space as their
        associated
        <methodname>source()</methodname>
        and
        <methodname>sink()</methodname>
        calls. In the case of the Hadoop
        platform, this will likely be on the cluster side, unlike calls to
        <methodname>*ConfInit()</methodname>
        which will likely be on the client
        side.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Advanced Processing</title>
    </info>

    <section>
      <title xreflabel="SubAssemblies"
             xml:id="subassemblies">SubAssemblies
      </title>

      <para>In Cascading, SubAssemblies are reusable pipe assemblies that are
        linked into larger pipe assemblies. They function much like subroutines
        in a larger program. SubAssemblies are a good way to organize complex
        pipe assemblies, and they allow for commonly-used pipe assemblies to be
        packaged into libraries for inclusion in other projects by other
        users.
      </para>

      <para>To create a SubAssembly, subclass the
        <classname>cascading.pipe.SubAssembly</classname>
        class.
      </para>

      <example>
        <title>Creating a SubAssembly</title>

        <xi:include href="custom-subassembly.xml"/>
      </example>

      <para>In the example above, we pass in (as parameters via the
        constructor) the pipes that we wish to continue assembling against, and
        in the last line we register the "join" pipe as a tail. This allows
        SubAssemblies to be nested within larger pipe assemblies or other
        SubAssemblies.
      </para>

      <example>
        <title>Using a SubAssembly</title>

        <xi:include href="simple-subassembly.xml"/>
      </example>

      <para>The example above demonstrates how to include a SubAssembly into a
        new pipe assembly.
      </para>

      <para>Note that in a SubAssembly that represents a split - that is, a
        SubAssembly with two or more tails - you can use the
        <methodname>getTails()</methodname>
        method to access the array of tails
        set internally by the
        <methodname>setTails()</methodname>
        method.
      </para>

      <example>
        <title>Creating a Split SubAssembly</title>

        <xi:include href="split-subassembly.xml"/>
      </example>

      <example>
        <title>Using a Split SubAssembly</title>

        <xi:include href="simple-split-subassembly.xml"/>
      </example>

      <para>To rephrase, if a
        <classname>SubAssembly</classname>
        does not
        split the incoming Tuple stream, the SubAssembly instance can be passed
        directly to the next Pipe instance. But, if the
        <classname>SubAssembly</classname>
        splits the stream into multiple
        branches, handles will be needed to access them. The solution is to pass
        each branch tail to the
        <methodname>setTails()</methodname>
        method, and
        call the
        <methodname>getTails()</methodname>
        method to get handles for
        the desired branches, which can be passed to subsequent instances of
        <classname>Pipe</classname>.
      </para>
    </section>

    <section>
      <title xreflabel="Stream Assertions" xml:id="stream-assertions">Stream
        Assertions
      </title>

      <mediaobject>
        <imageobject role="fo">
          <imagedata align="center" contentwidth="6in"
                     fileref="images/stream-assertions.svg"/>
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" contentwidth="6in"
                     fileref="images/stream-assertions.png"/>
        </imageobject>
      </mediaobject>

      <para>Stream assertions are simply a mechanism for asserting that one or
        more values in a tuple stream meet certain criteria. This is similar to
        the Java language "assert" keyword, or a unit test. An example would be
        "assert not null" or "assert matches".
      </para>

      <para>Assertions are treated like any other function or aggregator in
        Cascading. They are embedded directly into the pipe assembly by the
        developer. By default, if an assertion fails, the processing fails. As
        an alternative, an assertion failure can be caught by a failure
        Trap.
      </para>

      <para>Assertions may be more, or less, desirable in different contexts.
        For this reason, stream assertions can be treated as either "strict" or
        "validating".
        <emphasis role="italic">Strict</emphasis>
        assertions make
        sense when running tests against regression data - which should be
        small, and should represent many of the edge cases that the processing
        assembly must robustly support.
        <emphasis role="italic">Validating
        </emphasis>
        assertions, on the other hand, make more sense when running
        tests in staging, or when using data that may vary in quality due to an
        unmanaged source.
      </para>

      <para>And of course there are cases where assertions are unnecessary and
        only impede processing, and it would be best to just bypass them
        altogether.
      </para>

      <para>To handle all three of these situations, Cascading can be
        instructed to
        <emphasis role="italic">plan out</emphasis>
        (i.e., omit)
        strict assertions, validation assertions, or both when building the
        Flow. To create optimal performance, Cascading implements this by
        actually leaving the undesired assertions out of the final Flow (not
        merely switching them off).
      </para>

      <example>
        <title>Adding Assertions</title>

        <xi:include href="simple-assertion.xml"/>
      </example>

      <para>Again, assertions are added to a pipe assembly like any other
        operation, except that the
        <classname>AssertionLevel</classname>
        must be
        set to tell the planner how to treat the assertion during
        planning.
      </para>

      <example>
        <title>Planning Out Assertions</title>

        <xi:include href="simple-assertion-planner.xml"/>
      </example>

      <para>To configure the planner to remove some or all assertions, a
        property can be set via the
        <classname>FlowConnectorProps.setAssertionLevel()</classname>
        method or
        directly on the
        <classname>FlowDef</classname>
        instance, as shown above.
        Setting
        <classname>AssertionLevel.NONE</classname>
        removes all
        assertions.
        <classname>AssertionLevel.VALID</classname>
        keeps
        <code>VALID</code>
        assertions but removes
        <code>STRICT</code>
        ones. And
        <classname>AssertionLevel.STRICT</classname>
        keeps all assertions - the
        planner default value.
      </para>
    </section>

    <section>
      <title xreflabel="Failure Traps" xml:id="failure-traps">Failure
        Traps
      </title>

      <para>The following diagram shows the use of
        <emphasis
          role="italic">Failure Traps
        </emphasis>
        in a pipe assembly.
      </para>

      <para>
        <inlinemediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="5in"
                       fileref="images/failure-traps.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="5in"
                       fileref="images/failure-traps.png"/>
          </imageobject>
        </inlinemediaobject>
      </para>

      <para>Failure Traps are similar to tap sinks (as opposed to tap sources)
        in that they allow data to be stored. The difference is that Tap sinks
        are bound to a particular tail pipe in a pipe assembly and are the
        primary outlet of a branch in a pipe assembly. Traps can be bound to
        intermediate pipe assembly branches - just like Stream Assertions - yet
        they only capture data that causes an Operation to fail (throw an
        Exception).
      </para>

      <para>Whenever an operation fails and throws an exception, if there is
        an associated trap, the offending Tuple is saved to the resource
        specified by the trap Tap. This allows the job to continue processing
        without any data loss.
      </para>

      <para>By design, clusters are hardware fault-tolerant - lose a node, and
        the cluster continues working. But fault tolerance for software is a
        little different. Failure Traps provide a means for the processing to
        continue without losing track of the data that caused the fault. For
        high fidelity applications, this may not be very useful, since you
        likely will want any errors during processing to cause the application
        to stop. But for low fidelity applications such as webpage indexing,
        where skipping a page or two out of a few million is acceptable, this
        can dramatically improve processing reliability.
      </para>

      <example>
        <title>Setting Traps</title>

        <xi:include href="simple-traps.xml"/>
      </example>

      <para>The example above binds a trap tap to the pipe assembly segment
        named "assertions". Note how we can name branches and segments by using
        a single
        <classname>Pipe</classname>
        instance, and that the naming
        applies to all subsequent
        <classname>Pipe</classname>
        instances.
      </para>

      <para>Traps are for exceptional cases, in the same way that Java
        Exception handling is. Traps are not intended for application flow
        control, and not a means to filter some data into other locations.
        Applications that need to filter out bad data should do so explicitly,
        using filters. For more on this, see<xref
          linkend="handling-bad-data"/>.
      </para>
    </section>

    <section>
      <title>Checkpointing</title>

      <para>New to Cascading 2, and only supported by the Hadoop planner, is
        the ability to "checkpoint" data within a Flow by using the
        <classname>cascading.pipe.Checkpoint</classname>
        <classname>Pipe</classname>. That is, a Tuple stream can be persisted to
        disk at most any arbitrary point. Doing so forces a new FlowStep
        (MapReduce job when using Hadoop) after the checkpoint position.
      </para>

      <para>By default the checkpoint is anonymous and is cleaned up
        immediately after the Flow completes. This feature is useful when used
        in conjunction with a HashJoin where the small side of the join starts
        out extremely large but is filtered down to fit into memory before being
        read into the HashJoin. By forcing a checkpoint before the HashJoin,
        only the small filtered version of the data is replicated over the
        cluster. Without the checkpoint, it is likely the full unfiltered file
        will be replicated to every node the FlowStep is executing.
      </para>

      <para>Alternatively, checkpointing is useful for debugging when used
        with a checkpoint Tap, where the Tap has specified a TextDelimited
        Scheme without any declared Fields.
      </para>

      <example>
        <title>Adding a Checkpoint</title>

        <xi:include href="checkpoint-flow.xml"/>
      </example>

      <para>As can be seen above, we instantiate a new
        <classname>Checkpoint</classname>
        tap by passing it the previous
        <classname>Every</classname>
        <classname>Pipe</classname>. This will be
        the point at which data is persisted. Since we wish to keep the data
        after the
        <classname>Flow</classname>
        has completed, we create a
        <code>checkpointTap</code>
        that saves the data as a TAB delimited text
        file. We also specify that field names should be written out into a
        header file on the
        <classname>TextDelimited</classname>
        constructor.
        Finally the
        <classname>Tap</classname>
        is bound to the
        <classname>Checkpoint</classname>
        <classname>Pipe</classname>
        using the
        <classname>FlowDef</classname>.
      </para>
    </section>

    <section>
      <title>Restarting a Checkpointed Flow</title>
      <para>When using Checkpoint pipes in a Flow and the Flow fails, a future execution of the Flow
        can be restarted after the last successful FlowStep writing to a checkpoint file. That is, a Flow
        will only restart from the last Checkpoint Pipe location.
      </para>

      <para>This feature requires that the failed Flow be planned with a
        <code>runID</code>
        set on
        the FlowDef, and the retry Flow use the same
        <code>runID</code>
        value. It goes without
        saying, the retry Flow should be (roughly) equivant to the previous failed attempt.
      </para>

      <example>
        <title>Setting runID</title>

        <xi:include href="checkpoint-restart-flow.xml"/>
      </example>

      <para>Caution should be used when using restarted checkpoint Flows. If the input data has
        changed, or the pipe assembly has significantly been altered, the Flow may fail or there may
        be undetectable errors.
      </para>

      <para>Note that when using a<code>runID</code>, all Flow instances must use a unique value
        unless they are intended as a retry attempt. The runID value is used to scope the
        directories for the temporary checkpoint files to prevent file name collisions.
      </para>

      <para>On successful completion of a Flow with a runID, all temporary checkpoint files will be
        removed, if any.
      </para>
    </section>

    <section>
      <title>Flow and Cascade Event Handling</title>

      <para>Each Flow and Cascade has the ability to execute callbacks via an event listener. This
        ability is useful when an external application needs to be notified that either a Flow or
        Cascade has started, halted, completed, or either has thrown an exception.
      </para>

      <para>For instance, at the completion of a flow that runs on an Amazon
        EC2 Hadoop cluster, an Amazon SQS message can be sent to notify another
        application to fetch the job results from S3 or begin the shutdown of
        the cluster.
      </para>

      <para>Flows support event listeners through the
        <classname>cascading.flow.FlowListener</classname>
        interface and Cascades support event
        listeners through the<classname>cascading.cascade.CascadeListener</classname>, which
        supports four events:
      </para>

      <variablelist>
        <varlistentry>
          <term>onStarting</term>

          <listitem>
            <para>The onStarting event is fired when a Flow or Cascade instance receives the
              <code>start()</code>
              message.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>onStopping</term>

          <listitem>
            <para>The onStopping event is fired when a Flow or Cascade instance receives the
              <code>stop()</code>
              message.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>onCompleted</term>

          <listitem>
            <para>The onCompleted event is fired when a Flow or Cascade instance has completed all
              work, regardless of success or failure. If an exception was thrown, onThrowable will
              be fired before this event.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>onThrowable</term>

          <listitem>
            <para>The onThrowable event is fired if any internal job client throws a Throwable type.
              This throwable is passed as an argument to the event. onThrowable should return true
              if the given throwable was handled, and should not be rethrown from the
              <code>Flow.complete()</code>
              or
              <code>Cascade.complete()</code>
              methods.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title xreflabel="Template Taps" xml:id="template-tap">Template
        taps
      </title>

      <para>The
        <classname>TemplateTap</classname>
        <classname>Tap</classname>
        class provides a simple means to break large datasets into smaller sets
        based on data item values. This is commonly called partitioning or
        <emphasis role="italic">binning</emphasis>
        the data, where each "bin" of
        data is named after some data value(s) shared by the members of that
        bin. For example, this is a simple way to organize log files by month
        and year.
      </para>

      <xi:include href="template-tap.xml"/>

      <para>In the example above, we construct a parent
        <classname>Hfs</classname>
        <classname>tap</classname>
        and pass it to the
        constructor of a
        <classname>Templatetap</classname>
        instance, along with
        a String format "template". This format template is populated in the
        order in which values are declared via the
        <classname>Scheme</classname>
        class. If more complex path formatting is necessary, you may subclass
        the<classname>Templatetap</classname>.
      </para>

      <para>Note that you can only create sub-directories to bin data into.
        Hadoop must still write "part" files into each bin directory, and there
        is no safe mechanism for manipulating part file names.
      </para>

      <para>One last thing to keep in mind is whether binning happens during
        the Map phase or the Reduce phase. By doing a
        <classname>GroupBy</classname>
        on the values used to populate the
        template, binning will happen during the Reduce phase, and will likely
        scale much better in cases where there are a very large number of unique
        values used in the template resulting in a large number of
        directories.
      </para>
    </section>

    <section>
      <title>Partial Aggregation instead of Combiners</title>

      <para>In Hadoop mode, Cascading does not support MapReduce "Combiners".
        Combiners are a simple optimization allowing some Reduce functions to
        run on the Map side of MapReduce. Combiners are very powerful in that
        they reduce the I/O between the Mappers and Reducers - why send all of
        your Mapper data to Reducers when you can compute some values on the Map
        side and combine them in the Reducer? But Combiners are limited to
        Associative and Commutative functions only, such as "sum" and "max". And
        the process requires that the values emitted by the Map task must be
        serialized, sorted (which involves deserialization and comparison),
        deserialized again, and operated on - after which the results are again
        serialized and sorted. Combiners trade CPU for gains in I/O.
      </para>

      <para>Cascading takes a different approach. It provides a mechanism to
        perform partial aggregations on the Map side and combine the results on
        the Reduce side, but trades memory, instead of CPU, for I/O gains by
        caching values (up to a threshold limit). This bypasses the redundant
        serialization, deserialization, and sorting. Also, Cascading allows any
        aggregate function to be implemented - not just Associative and
        Commutative functions.
      </para>

      <para>Cascading supports a few built-in partial aggregate operations, including AverageBy,
        CountBy, SumBy, and FirstBy. These are actually SubAssemblies, not Operations, and are
        subclasses of the AggregateBy SubAssembly. For more on this, see the section on<xref
          linkend="aggregate-by"/>.
      </para>

      <para>Using partial aggregate operations is quite easy. They are
        actually less verbose than a standard Aggregate operation.
      </para>

      <example>
        <title>Using a SumBy</title>

        <xi:include href="partials-sumby.xml"/>
      </example>

      <para>For composing multiple partial aggregate operations, things are
        done a little differently.
      </para>

      <example>
        <title>Composing partials with AggregateBy</title>

        <xi:include href="partials-compose.xml"/>
      </example>

      <para>It's important to note that a
        <classname>GroupBy</classname>
        Pipe
        is embedded in the resulting assemblies above. But only one GroupBy is
        performed in the case of the AggregateBy, and all of the partial
        aggregations will be performed simultaneously. It is also important to
        note that, depending on the final pipe assembly, the Map side partial
        aggregate functions may be planned into the previous Reduce operation in
        Hadoop, further improving the performance of the application.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Built-In Operations</title>
    </info>

    <section>
      <title>Identity Function</title>

      <para>The
        <classname>cascading.operation.Identity</classname>
        function
        is used to "shape" a tuple stream. Here are some common patterns that
        illustrate how Cascading "field algebra" works. (Note that, in actual
        practice, some of these example tasks might be better performed with
        helper subassemblies such as
        <classname>cascading.pipe.assembly.Rename</classname>,
        <classname>cascading.pipe.assembly.Retain</classname>, and
        <classname>cascading.pipe.assemblyDiscard</classname>.)
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>Discard unused fields</term>

            <listitem>
              <para>Here Identity passes its arguments out as results, thanks
                to the
                <code>Fields.ARGS</code>
                field declaration.
              </para>

              <xi:include href="identity-discard-fields-long.xml"/>

              <para>In practice the field declaration can be left out, as
                <code>Field.ARGS</code>
                is the default declaration for the
                Identity function. And
                <code>Fields.RESULTs</code>
                can be left
                off, as it is the default for the
                <classname>Every</classname>
                pipe. Thus, simpler code yields the same result:
              </para>

              <xi:include href="identity-discard-fields.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Rename all fields</term>

            <listitem>
              <para>Here Identity renames the incoming arguments. Since
                Fields.RESULTS is implied, the incoming Tuple is replaced by the
                selected arguments and given new field names as declared on
                Identity.
              </para>

              <xi:include href="identity-rename-fields-explicit.xml"/>

              <para>In the example above, if there were more fields than "ip"
                and "method", it would work fine - all the extra fields would be
                discarded. But if the same were true for the next example, the
                planner would fail.
              </para>

              <xi:include href="identity-rename-fields-long.xml"/>

              <para>Since
                <code>Fields.ALL</code>
                is the default argument
                selector for the
                <classname>Each</classname>
                pipe, it can be
                left out as shown below. Again, the above and below examples
                will fail unless there are exactly two fields in the tuples of
                the incoming stream.
              </para>

              <xi:include href="identity-rename-fields.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Rename a single field</term>

            <listitem>
              <para>Here we rename a single field and return it, along with an
                input Tuple field, as the result. All other fields are
                dropped.
              </para>

              <xi:include href="identity-rename-some.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Coerce values to specific primitive types</term>

            <listitem>
              <para>Here we replace the Tuple String values "status" and
                "size" with
                <classname>int</classname>
                and
                <classname>long</classname>
                values, respectively. All other
                fields are dropped.
              </para>

              <xi:include href="identity-coerce.xml"/>

              <para>Or we can replace just the Tuple String value "status"
                with an<classname>int</classname>, while keeping all the other
                values in the output Tuple.
              </para>

              <xi:include href="identity-coerce-single.xml"/>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title xreflabel="Debug Function" xml:id="debug-function">Debug
        Function
      </title>

      <para>The
        <classname>cascading.operation.Debug</classname>
        function is a
        utility function (actually, it's a<classname>Filter</classname>) that
        prints the current argument Tuple to either
        <code>stdout</code>
        or
        <code>stderr</code>. Used with one of the
        <classname>DebugLevel</classname>
        enum values
        (<classname>NONE</classname>,<classname>DEFAULT</classname>, or
        <classname>VERBOSE</classname>), different debug levels can be embedded
        in a pipe assembly.
      </para>

      <para>The example below inserts a
        <classname>Debug</classname>
        operation
        at the
        <classname>VERBOSE</classname>
        level, but configures the planner
        to remove all
        <classname>Debug</classname>
        operations from the resulting
        <classname>Flow</classname>.
      </para>

      <xi:include href="flow-debug.xml"/>

      <para>Note that if the above Flow is run on a cluster, the
        <code>stdout</code>
        on the cluster nodes will be used. Nothing from the
        debug output will display on the client side. Debug is only useful when
        testing things in an IDE or if the remote logs are readily
        available.
      </para>
    </section>

    <section>
      <title>Sample and Limit Functions</title>

      <para>The Sample and Limit functions are used to limit the number of
        tuples that pass through a pipe assembly.
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>Sample</term>

            <listitem>
              <para>The
                <classname>cascading.operation.filter.Sample</classname>
                filter
                allows a percentage of tuples to pass.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Limit</term>

            <listitem>
              <para>The
                <classname>cascading.operation.filter.Limit</classname>
                filter
                allows a set number of tuples to pass.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Insert Function</title>

      <para>The
        <classname>cascading.operation.Insert</classname>
        function
        allows for insertion of constant literal values into the tuple
        stream.
      </para>

      <para>This is most useful when a splitting a tuple stream and one of the
        branches needs some identifying value, or when some missing parameter or
        value, like a date String for the current date, needs to be
        inserted.
      </para>
    </section>

    <section>
      <title>Text Functions</title>

      <para>Cascading includes a number of text functions in the
        <classname>cascading.operation.text</classname>
        package.
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>DateFormatter</term>

            <listitem>
              <para>The
                <classname>cascading.operation.text.DateFormatter</classname>
                function is used to convert a date timestamp to a formatted
                String. This function expects a
                <classname>long</classname>
                value representing the number of milliseconds since January 1,
                1970, 00:00:00 GMT/UTC, and formats the output using
                <classname>java.text.SimpleDateFormat</classname>
                syntax.
              </para>

              <xi:include href="text-format-date.xml"/>

              <para>The example above converts a
                <classname>long</classname>
                timestamp ("ts") to a date String.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>DateParser</term>

            <listitem>
              <para>The
                <classname>cascading.operation.text.DateParser</classname>
                function is used to convert a text date String to a timestamp,
                using the
                <classname>java.text.SimpleDateFormat</classname>
                syntax. The timestamp is a
                <classname>long</classname>
                value
                representing the number of milliseconds since January 1, 1970,
                00:00:00 GMT/UTC. By default, the output is a field with the
                name "ts" (for timestamp), but this can be overridden by passing
                a declared Fields value.
              </para>

              <xi:include href="text-create-timestamp.xml"/>

              <para>In the example above, an Apache log-style date-time field
                is converted into a
                <classname>long</classname>
                timestamp in
                UTC.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>FieldJoiner</term>

            <listitem>
              <para>The
                <classname>cascading.operation.text.FieldJoiner</classname>
                function joins all the values in a Tuple with a specified
                delimiter and places the result into a new field. (For the
                opposite effect, see the
                <classname>RegexSplitter</classname>
                function.)
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>FieldFormatter</term>

            <listitem>
              <para>The
                <classname>cascading.operation.text.FieldFormatter</classname>
                function formats Tuple values with a given String format and
                stuffs the result into a new field. The
                <classname>java.util.Formatter</classname>
                class is used to
                create a new formatted String.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Regular Expression Operations</title>

      <para>
        <variablelist>
          <varlistentry>
            <term>RegexSplitter</term>

            <listitem>
              <para>The
                <classname>cascading.operation.regex.RegexSplitter</classname>
                function splits an argument value based on a regex pattern
                String. (For the opposite effect, see the FieldJoiner function.)
                Internally, this function uses
                <classname>java.util.regex.Pattern.split()</classname>, and it
                behaves accordingly. By default, it splits on the TAB character
                ("\t"). If it is known that a determinate number of values will
                emerge from this function, it can declare field names. In this
                case, if the splitter encounters more split values than field
                names, the remaining values are discarded. For more information,
                see<classname>java.util.regex.Pattern.split( input, limit
                  )</classname>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>RegexParser</term>

            <listitem>
              <para>The
                <classname>cascading.operation.regex.RegexParser</classname>
                function is used to extract a regex-matched value from an
                incoming argument value. If the regular expression is
                sufficiently complex, an
                <classname>int</classname>
                array may be
                provided to specify which regex groups should be returned in
                which field names.
              </para>

              <xi:include href="regex-parser.xml"/>

              <para>In the example above, a line from an Apache access log is
                parsed into its component parts. Note that the
                <classname>int[]</classname>
                groups array starts at 1, not 0.
                Group 0 is the whole group, so if the first field is included,
                it is a copy of "line" and not "ip".
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>RegexReplace</term>

            <listitem>
              <para>The
                <classname>cascading.operation.regex.RegexReplace</classname>
                function is used to replace a regex-matched value with a
                specified replacement value. It can operate in a "replace all"
                or "replace first" mode. For more information, see the methods
                <classname>java.util.regex.Matcher.replaceAll()</classname>
                and
                <classname>java.util.regex.Matcher.replaceFirst()</classname>.
              </para>

              <xi:include href="regex-replace.xml"/>

              <para>In the example above, all adjoined white space characters
                are replaced with a single space character.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>RegexFilter</term>

            <listitem>
              <para>The
                <classname>cascading.operation.regex.RegexFilter</classname>
                function filters a Tuple stream based on a specified regex
                value. By default, tuples that match the given pattern are kept,
                and tuples that do not match are filtered out. This can be
                reversed by setting "removeMatch" to<code>true</code>. Also, by
                default, the whole Tuple is matched against the given regex
                String (in tab-delimited sections). If "matchEachElement" is set
                to<code>true</code>, the pattern is applied to each Tuple value
                individually. For more information, see the
                <classname>java.util.regex.Matcher.find()</classname>
                method.
              </para>

              <xi:include href="regex-filter.xml"/>

              <para>The above keeps all lines in which "68." appears at the
                start of the IP address.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>RegexGenerator</term>

            <listitem>
              <para>The
                <classname>cascading.operation.regex.RegexGenerator</classname>
                function emits a new tuple for every string (found in an input
                tuple) that matches a specified regex pattern.
              </para>

              <xi:include href="regex-generator.xml"/>

              <para>Above each "line" in a document is parsed into unique
                words and stored in the "word" field of each result
                Tuple.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>RegexSplitGenerator</term>

            <listitem>
              <para>The
                <classname>cascading.operation.regex.RegexSplitGenerator</classname>
                function emits a new Tuple for every split on the incoming
                argument value delimited by the given pattern String. The
                behavior is similar to the
                <classname>RegexSplitter</classname>
                function, except that (assuming multiple matches)
                <classname>RegexSplitter</classname>
                emits a single tuple that
                may contain multiple values, and
                <classname>RegexSplitGenerator</classname>
                emits multiple tuples
                that each contain only one value, as does
                <classname>RegexGenerator</classname>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title xreflabel="Expression Operations"
             xml:id="operation-expression">Java Expression Operations
      </title>

      <para>Cascading provides some support for dynamically-compiled Java
        expressions to be used in either
        <classname>Functions</classname>
        or
        <classname>Filters</classname>. This capability is provided by the
        Janino embedded Java compiler, which compiles the expressions into byte
        code for optimal processing speed. Janino is documented in detail on its
        website,<link
          xlink:href="http://www.janino.net/">http://www.janino.net/</link>.
      </para>

      <para>This capability allows an Operation to evaluate a suitable
        one-line Java expression, such as
        <code>a + 3 * 2</code>
        or<code>a &lt;
          7</code>, where the variable values (
        <code>a</code>
        and<code>b</code>)
        are passed in as Tuple fields. The result of the Operation thus depends
        on the evaluated result of the expression - in the first example, some
        number, and in the second, a Boolean value.
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>ExpressionFunction</term>

            <listitem>
              <para>The function
                <classname>cascading.operation.expression.ExpressionFunction</classname>
                dynamically composes a string expression when executed,
                assigning argument Tuple values to variables in the
                expression.
              </para>

              <xi:include href="expression-function.xml"/>

              <para>Above, we create a new String value that contains an
                expression containing values from the current Tuple. Note that
                you must declare the type for every input Tuple field so that
                the expression compiler knows how to treat the variables in the
                expression.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>ExpressionFilter</term>

            <listitem>
              <para>The filter
                <classname>cascading.operation.expression.ExpressionFilter</classname>
                evaluates a Boolean expression, assigning argument Tuple values
                to variables in the expression. If the expression returns
                <code>true</code>, the Tuple is removed from the stream.
              </para>

              <xi:include href="expression-filter.xml"/>

              <para>In this example, every line in the Apache log that does
                not have a status of "200" is filtered out. ExpressionFilter
                coerces the value into the specified type if necessary to make
                the comparison - in this case, coercing the status String into
                an<classname>int</classname>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>XML Operations</title>

      <para>To use XML Operations in a Cascading application, include the
        <filename>cascading-xml-x.y.z.jar</filename>
        in the project. When using
        the
        <classname>TagSoupParser</classname>
        operation, this module requires
        the TagSoup library, which provides support for HTML and XML "tidying".
        More information is available at the TagSoup website,<link
          xlink:href="http://home.ccil.org/~cowan/XML/tagsoup/">http://home.ccil.org/~cowan/XML/tagsoup/</link>.
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>XPathParser</term>

            <listitem>
              <para>The
                <classname>cascading.operation.xml.XPathParser</classname>
                function uses one or more XPath expressions, passed into the
                constructor, to extract one or more node values from an XML
                document contained in the passed Tuple argument, and places the
                result(s) into one or more new fields in the current Tuple. In
                this way, it effectively parses an XML document into a table of
                fields, creating one Tuple field value for every given XPath
                expression. The
                <classname>Node</classname>
                is converted to a
                String type containing an XML document. If only the text values
                are required, search on the
                <code>text()</code>
                nodes, or
                consider using XPathGenerator to handle multiple
                <classname>NodeList</classname>
                values. If the returned result
                of an XPath expression is a<classname>NodeList</classname>, only
                the first
                <classname>Node</classname>
                is used for the field
                value and the rest are ignored.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>XPathGenerator</term>

            <listitem>
              <para>Similar to XPathParser, the
                <classname>cascading.operation.xml.XPathGenerator</classname>
                function emits a new
                <classname>Tuple</classname>
                for every
                <classname>Node</classname>
                returned by the given XPath
                expression from the XML in the current Tuple.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>XPathFilter</term>

            <listitem>
              <para>The filter
                <classname>cascading.operation.xml.XPathFilter</classname>
                removes a Tuple if the specified XPath expression returns
                <code>false</code>. Set the removeMatch parameter to
                <code>true</code>
                if the filter should be reversed, i.e., to
                keep only those Tuples where the XPath expression returns
                <code>true</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>TagSoupParser</term>

            <listitem>
              <para>The
                <classname>cascading.operation.xml.TagSoupParser</classname>
                function uses the TagSoup library to convert incoming HTML to
                clean XHTML. Use the
                <code>setFeature( feature, value )</code>
                method to set TagSoup-specific features, which are documented on
                the TagSoup website.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Assertions</title>

      <para>Cascading Stream Assertions are used to build robust reusable pipe
        assemblies. If desired, they can be planned out of a Flow instance at
        runtime. For more information, see the section on<xref
          linkend="stream-assertions"/>. Below we describe the Assertions
        available in the core library.
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>AssertEquals</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertEquals</classname>
                Assertion asserts that the number of values given on the
                constructor is equal to the number of argument Tuple values, and
                that each constructor value
                <code>.equals()</code>
                its
                corresponding argument value.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertNotEquals</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertNotEquals</classname>
                Assertion asserts that the number of values given on the
                constructor is equal to the number of argument Tuple values and
                that each constructor value is not
                <code>.equals()</code>
                to its
                corresponding argument value.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertEqualsAll</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertEqualsAll</classname>
                Assertion asserts that every value in the argument Tuple
                <code>.equals()</code>
                the single value given on the
                constructor.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertExpression</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertExpression</classname>
                Assertion dynamically resolves a given Java expression (see
                <xref linkend="operation-expression"/>) using argument Tuple
                values. Any Tuple that returns
                <code>true</code>
                for the given
                expression passes the assertion.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertMatches</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertMatches</classname>
                Assertion matches the given regular expression pattern String
                against the entire argument Tuple. The comparison is made
                possible by concatenating all the fields of the Tuple, separated
                by the TAB character (\t). If a match is found, the Tuple passes
                the assertion.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertMatchesAll</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertMatchesAll</classname>
                Assertion matches the given regular expression pattern String
                against each argument Tuple value individually.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertNotNull</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertNotNull</classname>
                Assertion asserts that every position/field in the argument
                Tuple is not<code>null</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertNull</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertNull</classname>
                Assertion asserts that every position/field in the argument
                Tuple is<code>null</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertSizeEquals</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertSizeEquals</classname>
                Assertion asserts that the current Tuple in the tuple stream is
                exactly the given size. Size, here, is the number of fields in
                the Tuple, as returned by<code>Tuple.size()</code>. Note that
                some or all fields may be<code>null</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertSizeLessThan</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertSizeLessThan</classname>
                Assertion asserts that the current Tuple in the stream has a
                size less than (<code>&lt;</code>) the given size. Size, here,
                is the number of fields in the Tuple, as returned by
                <code>Tuple.size()</code>. Note that some or all fields may be
                <code>null</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertSizeMoreThan</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertSizeMoreThan</classname>
                Assertion asserts that the current Tuple in the stream has a
                size greater than (<code>&gt;</code>) the given size. Size,
                here, is the number of fields in the Tuple, as returned by
                <code>Tuple.size()</code>. Note that some or all fields may be
                <code>null</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertGroupSizeEquals</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertGroupSizeEquals</classname>
                Group Assertion asserts that the number of items in the current
                grouping is equal to (<code>==</code>) the given size. If a
                pattern String is given, only grouping keys that match the
                regular expression will have this assertion applied where
                multiple key values are delimited by a TAB character.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertGroupSizeLessThan</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertGroupSizeEquals</classname>
                Group Assertion asserts that the number of items in the current
                grouping is less than (<code>&lt;</code>) the given size. If a
                pattern String is given, only grouping keys that match the
                regular expression will have this assertion applied where
                multiple key values are delimited by a TAB character.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>AssertGroupSizeMoreThan</term>

            <listitem>
              <para>The
                <classname>cascading.operation.assertion.AssertGroupSizeEquals</classname>
                Group Assertion asserts that the number of items in the current
                grouping is greater than (<code>&gt;</code>) the given size. If
                a pattern String is given, only grouping keys that match the
                regular expression will have this assertion applied where
                multiple key values are delimited by a TAB character.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Logical Filter Operators</title>

      <para>The logical
        <classname>Filter</classname>
        operators allow you to
        combine multiple filters to run in a single Pipe, instead of chaining
        multiple Pipes together to get the same logical result.
      </para>

      <para>
        <variablelist>
          <varlistentry>
            <term>And</term>

            <listitem>
              <para>The
                <classname>cascading.operation.filter.And</classname>
                <classname>Filter</classname>
                performs a logical "and" on the
                results of the constructor-provided
                <classname>Filter</classname>
                instances. That is, if
                <methodname>Filter#isRemove()</methodname>
                returns
                <code>true</code>
                for all of the given instances, this filter
                returns<code>true</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Or</term>

            <listitem>
              <para>The
                <classname>cascading.operation.filter.Or</classname>
                <classname>Filter</classname>
                performs a logical "or" on the
                results of the constructor-provided
                <classname>Filter</classname>
                instances. That is, if
                <methodname>Filter#isRemove()</methodname>
                returns
                <code>true</code>
                for any of the given instances, this filter
                returns<code>true</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Not</term>

            <listitem>
              <para>The
                <classname>cascading.operation.filter.Not</classname>
                <classname>Filter</classname>
                performs a logical "not"
                (negation) on the results of the constructor-provided
                <classname>Filter</classname>
                instance. That is, if
                <methodname>Filter#isRemove()</methodname>
                returns
                <code>true</code>
                for the given instance, this filter returns
                <code>false</code>, and if
                <methodname>Filter#isRemove()</methodname>
                returns
                <code>false</code>
                for the given instance, this filter returns
                <code>true</code>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Xor</term>

            <listitem>
              <para>The
                <classname>cascading.operation.filter.Xor</classname>
                <classname>Filter</classname>
                performs a logical "xor"
                (exclusive or) on the results of the constructor-provided
                <classname>Filter</classname>
                instances. Xor can only be applied
                to two instances at a time. It returns
                <code>true</code>
                if the
                two instances have different truth values, and
                <code>false</code>
                if they have the same truth value. That is,
                if
                <methodname>Filter.isRemove()</methodname>
                returns
                <code>true</code>
                for both, or returns
                <code>false</code>
                for
                both, this filter returns<code>false</code>; otherwise it
                returns<code>true</code>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>

      <example>
        <title>Combining Filters</title>

        <xi:include href="filter-and.xml"/>
      </example>

      <para>The example above performs a logical "and" on the two filters.
        Both must be satisfied for the data to pass through this one
        Pipe.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Built-in Assemblies</title>
    </info>

    <para>There are a number of helper SubAssemblies provided by the core
      cascading library.
    </para>

    <section>
      <title xreflabel="AggregateBy" xml:id="aggregate-by">AggregateBy</title>

      <para>The
        <classname>cascading.pipe.assembly.AggregateBy</classname>
        SubAssembly is an implementation of the Partial Aggregation pattern, and
        is the base class for built-in and custom partial aggregation
        implementations like
        <classname>AverageBy</classname>
        or
        <classname>CountBy</classname>.
      </para>

      <para>Generally the AggregateBy class is used to combine multiple
        AggregateBy subclasses into a single Pipe.
      </para>

      <example>
        <title>Composing partials with AggregateBy</title>

        <xi:include href="partials-compose.xml"/>
      </example>

      <para>To create a custom partial aggregation, subclass the AggregateBy
        class and implement the appropriate internal interfaces. See the Javadoc
        for details.
      </para>

      <section>
        <title xml:id="AverageBy">AverageBy</title>

        <para>The
          <classname>cascading.pipe.assembly.AverageBy</classname>
          SubAssembly performs an average over the given
          <code>valueFields</code>
          and returns the result in the
          <code>averageField</code>
          field. AverageBy may be combined with other
          AggregateBy subclasses so they may be executed simultaneously over the
          same grouping.
        </para>

        <example>
          <title>Using AverageBy</title>

          <xi:include href="partials-averageby.xml"/>
        </example>
      </section>

      <section>
        <title xml:id="CountBy">CountBy</title>

        <para>The
          <classname>cascading.pipe.assembly.CountBy</classname>
          SubAssembly performs a count over the given
          <code>groupingFields</code>
          and returns the result in the
          <code>countField</code>
          field. CountBy may be combined with other
          AggregateBy subclasses so they may be executed simultaneously over the
          same grouping.
        </para>

        <example>
          <title>Using CountBy</title>

          <xi:include href="partials-countby.xml"/>
        </example>
      </section>

      <section>
        <title xml:id="SumBy">SumBy</title>

        <para>The
          <classname>cascading.pipe.assembly.SumBy</classname>
          SubAssembly performs a sum over the given
          <code>valueFields</code>
          and
          returns the result in the
          <code>sumField</code>
          field. SumBy may be
          combined with other AggregateBy subclasses so they may be executed
          simultaneously over the same grouping.
        </para>

        <example>
          <title>Using SumBy</title>

          <xi:include href="partials-sumby.xml"/>
        </example>
      </section>

      <section>
        <title>FirstBy</title>
        <para>The
          <classname>cascading.pipe.assembly.FirstBy</classname>
          SubAssembly is used to
          return the first encountered value in the given<code>valueFields</code>. FirstBy may be combined
          with other AggregateBy subclasses so they may be executed simultaneously over the same
          grouping.
        </para>

        <example>
          <title>Using FirstBy</title>

          <xi:include href="partials-firstby.xml"/>
        </example>

        <para>Note if the
          <code>valueFields</code>
          Fields instance has field comparators, they will
          be used to sort the argument values to influence what values are seen first. Otherwise the
          fields will not be sorted in any deterministic order.
        </para>
      </section>
    </section>

    <section>
      <title>Coerce</title>

      <para>The
        <classname>cascading.pipe.assembly.SumBy</classname>
        SubAssembly is used to coerce a set of values from one type to another
        type - for example, to convert the field
        <code>age</code>
        from a
        <classname>String</classname>
        to an
        <classname>Integer</classname>.
      </para>

      <example>
        <title>Using Coerce</title>

        <xi:include href="subassembly-coerce.xml"/>
      </example>
    </section>

    <section>
      <title>Discard</title>

      <para>The
        <classname>cascading.pipe.assembly.Discard</classname>
        SubAssembly is used to shape the Tuple stream by discarding all fields
        given on the constructor. All fields not listed are retained.
      </para>

      <example>
        <title>Using Discard</title>

        <xi:include href="subassembly-discard.xml"/>
      </example>
    </section>

    <section>
      <title>Rename</title>

      <para>The
        <classname>cascading.pipe.assembly.Rename</classname>
        SubAssembly is used to rename a field.
      </para>

      <example>
        <title>Using Rename</title>

        <xi:include href="subassembly-rename.xml"/>
      </example>
    </section>

    <section>
      <title>Retain</title>

      <para>The
        <classname>cascading.pipe.assembly.Retain</classname>
        SubAssembly is used to shape the Tuple stream by retaining all fields
        given on the constructor. All fields not listed are discarded.
      </para>

      <example>
        <title>Using Retain</title>

        <xi:include href="subassembly-retain.xml"/>
      </example>
    </section>

    <section>
      <title>Unique</title>

      <para>The
        <classname>cascading.pipe.assembly.Unique</classname>
        SubAssembly is used to remove duplicate values in a Tuple stream.
        Uniqueness is determined by the values of all fields listed in
        <code>uniqueFields</code>. Thus to find all distinct Tuples in a Tuple
        stream, use
        <classname>Fields.ALL</classname>
        as the
        <code>uniqueFields</code>
        argument.
      </para>

      <example>
        <title>Using Unique</title>

        <xi:include href="subassembly-unique.xml"/>
      </example>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Best Practices</title>
    </info>

    <section>
      <title>Unit Testing</title>

      <para>Discrete testing of all Operations, pipe assemblies, and
        applications is a must. The
        <classname>cascading.CascadingTestCase</classname>
        provides a number of
        helper methods.
      </para>

      <para>When testing custom Operations, use the
        <methodname>invokeFunction()</methodname>,
        <methodname>invokeFilter()</methodname>,
        <methodname>invokeAggregator()</methodname>, and
        <methodname>invokeBuffer()</methodname>
        methods.
      </para>

      <para>When testing Flows, use the
        <methodname>validateLength()</methodname>
        methods. There are quite a few
        of them, and collectively they offer great flexibility. All of them read
        the sink tap, validate that it is the correct length and has the correct
        Tuple size, and check to see whether the values match a given regular
        expression pattern.
      </para>

      <para>As of Cascading 2, it is possible to write tests that are
        independent of the underlying platform or mode. Any unit test should
        subclass
        <classname>cascading.PlatformTestCase</classname>
        and apply the
        <classname>PlatformRunner.Platform</classname>
        annotation.
      </para>

      <para>For example, the annotation
        <code>@PlatformRunner.Platform({LocalPlatform.class,
          HadoopPlatform.class})
        </code>
        causes the PlatformTestCase to run all
        the unit tests defined on the subclass with the
        <classname>LocalPlatform</classname>
        and
        <classname>HadoopPlatform</classname>
        platform instances.
      </para>

      <para>See the Cascading unit tests for examples.</para>

      <para>To use any of these helper classes, make sure that
        <filename>cascading-test-x.y.z.jar</filename>
        is in your testing class
        path.
      </para>
    </section>

    <section>
      <title>Flow Granularity</title>

      <para>Although using one large
        <classname>Flow</classname>
        may result in
        slightly more efficient performance, it's advisable to use a more
        modular and flexible approach, creating medium or small Flows with
        well-defined responsibilities, and passing all the resulting
        interdependent Flows to a
        <classname>Cascade</classname>
        to sequence and
        execute as a single unit. Similarly, using the
        <classname>TextDelimited</classname>
        <classname>Scheme</classname>
        (or
        any custom format for long-term archival) between
        <classname>Flow</classname>
        instances allows you to hand off
        intermediate data to other systems for reporting or QA purposes,
        incurring a minimal performance penalty while remaining compatible with
        other tools.
      </para>
    </section>

    <section>
      <title>SubAssemblies, not Factories</title>

      <para>When developing your applications, use
        <classname>SubAssembly</classname>
        subclasses, not "factory" methods.
        The resulting code is much easier to read and test.
      </para>

      <para>It's worth noting that the
        <classname>Object</classname>
        constructors are "factories", so there isn't much reason to build
        frameworks to duplicate what a constructor already does. Of course there
        are exceptional cases in which you don't have the option to use a
        <classname>SubAssembly</classname>, but in practice they are
        rare.
      </para>
    </section>

    <section>
      <title>Logical Responsibilities for SubAssemblies</title>

      <para>SubAssembies provide a very convenient means to co-locate similar
        or related responsibilities into a single place. For example, it's
        simple to use a
        <classname>ParsingSubAssembly</classname>
        and a
        <classname>RulesSubAssembly</classname>, where the first is responsible
        solely for parsing incoming
        <classname>Tuple</classname>
        streams (log
        files for example), and the second applies rules to decide whether a
        given
        <classname>Tuple</classname>
        should be discarded or marked as
        bad.
      </para>

      <para>Additionally, in your unit tests you can create a
        <classname>TestAssertionsSubAssembly</classname>
        that simply inlines
        various
        <classname>ValueAssertions</classname>
        and
        <classname>GroupAssertions</classname>. The practice of inlining
        Assertions directly in your SubAssemblies is also important, but
        sometimes it makes sense to have more tests outside of the business
        logic.
      </para>
    </section>

    <section>
      <title>Java Operators in Field Names</title>

      <para>There are a few Operations in Cascading (e.g.,
        <classname>ExpressionFunction</classname>
        and
        <classname>ExpressionFilter</classname>) that compile and apply Java
        expressions on the fly. In these expressions, Operation argument field
        names are used as variable names in the expression. For this reason,
        take care to create field names that don't contain characters which will
        cause compilation errors if they are used in an expression. For example,
        "first-name" is a valid field name for use with Cascading, but might
        result in the expression<code>first-name.trim()</code>, which will cause
        a compilation error.
      </para>
    </section>

    <section>
      <title>Debugging Planner Failures</title>

      <para>The
        <classname>FlowConnector</classname>
        will sometimes fail when
        attempting to plan a<classname>Flow</classname>. If the error message
        given by
        <classname>PlannerException</classname>
        is vague, use the
        method
        <code>PlannerException.writeDOT()</code>
        to export a
        representation of the internal pipe assembly. DOT files can be opened by
        GraphViz and OmniGraffle. These plans are only partial, but you will be
        able to see where the Cascading planner failed.
      </para>

      <para>Note that you can also create a DOT file from a
        <classname>Flow</classname>, by using
        <code>Flow.writeDOT()</code>.
      </para>
    </section>

    <section>
      <title>Optimizing Joins</title>

      <para>When joining two streams via a
        <classname>CoGroup</classname>
        <classname>Pipe</classname>, try to put the largest of the streams in
        the leftmost argument to the<classname>CoGroup</classname>. The reason
        for this is that joining multiple streams requires some accumulation of
        values before the join operator can begin, but the leftmost stream is
        not accumulated, so this technique should improve the performance of
        most joins.
      </para>
    </section>

    <section>
      <title>Debugging Streams</title>

      <para>When creating complex assemblies, it's safe to embed
        <classname>Debug</classname>
        operations (see<xref
          linkend="debug-function"/>) at appropriate debug levels as needed. Use
        the planner to remove them at runtime for production and staging runs,
        to avoid wasting resources.
      </para>
    </section>

    <section>
      <title xreflabel="Handling Good and Bad Data" xml:id="handling-bad-data"
             xml:lang="">Handling Good and Bad Data
      </title>

      <para>It's very common when processing raw data streams to encounter
        data that is corrupt or malformed in some way. For instance, bad content
        may be fetched from the web via a crawler upstream, or a bug may have
        leaked into a browser widget somewhere that sends user behavior
        information back for analysis. Whatever the cause, it's a good practice
        to define a set of rules for identifying and discarding questionable
        records.
      </para>

      <para>It is tempting to simply throw an exception and have a Trap
        capture the offending<classname>Tuple</classname>, but Traps were not
        designed as a filtering mechanism, and consequently much valuable
        information would be lost.
      </para>

      <para>Instead of traps, use filters. Create a
        <classname>SubAssembly</classname>
        that applies rules to the stream by
        setting a binary field that marks the tuple as good or bad. After all
        the rules are applied, split the stream based on the value of the good
        or bad
        <classname>Boolean</classname>
        value. Consider setting a reason
        field that states why the Tuple was marked bad.
      </para>
    </section>

    <section>
      <title>Maintaining State in Operations</title>

      <para>When creating custom Operations (<classname>Function</classname>,
        <classname>Filter</classname>,<classname>Aggregator</classname>, or
        <classname>Buffer</classname>) do not store operation state in class
        fields.
      </para>

      <para>For example, if implementing a custom "counter"
        <classname>Aggregator</classname>, do not create a field named "count"
        and increment it on every
        <methodname>Aggregator.aggregate()</methodname>
        call. There is no
        guarantee that your Operation will be called from a single thread in a
        JVM - and future versions of Hadoop or Cascading local mode might
        execute the same operation from multiple threads.
      </para>
    </section>

    <section>
      <title>Custom Types</title>

      <para>Passing a custom class through a Tuple stream is generally frowned
        upon. It leads to the coupling of custom Operations to particular types,
        and it removes opportunities for reducing the amount of data that passes
        over the network.
      </para>

      <para>The first objection can be overcome with a little work. When using
        a custom type that has multiple instance fields, try to provide
        Functions that can promote a value from the custom object to a position
        in a Tuple, or demote the Tuple value for a particular field back into
        the custom type. This lets you use existing operations like
        <classname>ExpressionFunction</classname>
        or
        <classname>RegexFilter</classname>
        to operate on values owned by a
        custom type.
      </para>

      <para>For example, if you have a
        <classname>Person</classname>
        object,
        create a Function named
        <classname>GetPersonAge</classname>
        that takes
        Person as an argument and returns just the age. The next operation can
        then Filter all Persons based on their age. This may seem more difficult
        and less effiicient, but it keeps your application flexible and avoids
        duplicating existing operations. (The only alternative here is to create
        a<classname>PersonAgeFilter</classname>, which becomes one more thing to
        test.)
      </para>
    </section>

    <section>
      <title>Fields Constants</title>

      <para>Instead of having String field names strewn about, create an
        Interface that holds a constant value for each field name:
      </para>

      <para>
        <code>public static Fields FIRST_NAME = new Fields( "firstname" );
        </code>
      </para>

      <para>Using the Fields class, instead of String, allows for building
        more complex constants:
      </para>

      <para>
        <code>public static Fields NAME = FIRST_NAME.append( LAST_NAME );
        </code>
      </para>
    </section>

    <section>
      <title>Checking the Source Code</title>

      <para>When in doubt, look at the Cascading source code. If something is
        not documented in this User Guide or Javadoc, and it's a feature of
        Cascading, the feature source code or unit tests will give you clear
        instructions on what to do or expect.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title xml:id="extending-cascading">Extending Cascading</title>
    </info>

    <section>
      <title>Scripting</title>

      <para>The Cascading API was designed with scripting in mind. Any
        Java-compatible scripting language can import and instantiate Cascading
        classes, create pipe assemblies and flows, and execute those flows. And
        if the scripting language in question supports Domain Specific Language
        (DSL) creation, users can create their own DSLs to handle common
        idioms.
      </para>

      <para>The Cascading website includes information on scripting language
        bindings that are publicly available.
      </para>
    </section>

    <section>
      <title xreflabel="Custom Types" xml:id="custom-types">Custom Types and
        Serialization
      </title>

      <para>The
        <classname>Tuple</classname>
        class is a generic container for
        all
        <classname>java.lang.Object</classname>
        instances. Thus any
        primitive value or custom Class can be stored in a
        <classname>Tuple</classname>
        instance - that is, returned by a
        <classname>Function</classname>,<classname>Aggregator</classname>, or
        <classname>Buffer</classname>
        as a result value.
      </para>

      <para>But for this to work when using the Cascading Hadoop mode, any
        Class that isn't a primitive type or a Hadoop
        <classname>Writable</classname>
        type requires a corresponding Hadoop
        serialization class registered in the Hadoop configuration files for
        your cluster. Hadoop
        <classname>Writable</classname>
        types work because
        there is already a generic serialization implementation built into
        Hadoop. See the Hadoop documentation for information on registering a
        new serialization helper or creating
        <classname>Writable</classname>
        types. Registered serialization implementations are automatically
        inherited by Cascading.
      </para>

      <para>During serialization and deserialization of
        <classname>Tuple</classname>
        instances that contain custom types, the
        Cascading
        <classname>Tuple</classname>
        serialization framework must
        store the class name (as a<classname>String</classname>) before
        serializing the custom object. This can be very space-inefficient. To
        overcome this, custom types can add the
        <classname>SerializationToken</classname>
        Java annotation to the custom
        type class. The
        <classname>SerializationToken</classname>
        annotation
        expects two arrays - one of integers that are used as tokens, and one of
        Class name strings. Both arrays must be the same size. The integer
        tokens must all have values of 128 or greater, since the first 128
        values are reserved for internal use.
      </para>

      <para>During serialization and deserialization, the token values are
        used instead of the
        <classname>String</classname>
        Class names, in order
        to reduce the amount of storage used.
      </para>

      <para>Serialization tokens may also be stored in the Hadoop config files
        or set as a property passed to the<classname>FlowConnector</classname>,
        with the property name<code>cascading.serialization.tokens</code>. The
        value of this property is a comma separated list of
        <code>token=classname</code>
        values.
      </para>

      <para>Note that Cascading natively serializes/deserializes all
        primitives and byte arrays (<code>byte[]</code>), if the developer
        registers the
        <classname>BytesSerialization</classname>
        class by using
        <code>TupleSerializationProps.addSerialization(properties,
          BytesSerialization.class.getName()</code>. The token 127 is used for the
        Hadoop
        <classname>BytesWritable</classname>
        class.
      </para>

      <para>By default, Cascading uses lazy deserialization on Tuple elements
        during comparisons when Hadoop sorts keys during the "shuffle"
        phase.
      </para>

      <para>Cascading supports custom serialization for custom types, as well
        as lazy deserialization of custom types during comparisons. This is
        accomplished by implementing the
        <classname>StreamComparator</classname>
        interface. See the Javadoc for detailed instructions on implemention,
        and the unit tests for examples.
      </para>
    </section>

    <section>
      <title>Custom Comparators and Hashing</title>

      <para>Frequently, objects in one
        <classname>Tuple</classname>
        are
        compared to objects in a second<classname>Tuple</classname>. This is
        especially true during the sort phase of
        <classname>GroupBy</classname>
        and
        <classname>CoGroup</classname>
        in Cascading Hadoop mode . By
        default, Hadoop and Cascading use the native
        <classname>Object</classname>
        methods
        <methodname>equals()</methodname>
        and
        <methodname>hashCode()</methodname>
        to compare two values and get a
        consistent hash code for a given value, respectively.
      </para>

      <para>To override this default behavior, you can create a custom
        <classname>java.util.Comparator</classname>
        class to perform comparisons
        on a given field in a Tuple. For instance, to secondary-sort a
        collection of custom
        <classname>Person</classname>
        objects in a
        <classname>GroupBy</classname>, use the
        <code>Fields.setComparator()</code>
        method to designate the custom
        <classname>Comparator</classname>
        to the
        <classname>Fields</classname>
        instance that specifies the sort fields.
      </para>

      <para>Alternatively, you can set a default
        <classname>Comparator</classname>
        to be used by a
        <classname>Flow</classname>, or used locally on a given
        <classname>Pipe</classname>
        instance. There are two ways to do this.
        Call
        <code>FlowProps.setDefaultTupleElementComparator()</code>
        on a
        <classname>Properties</classname>
        instance, or use the property key
        <code>cascading.flow.tuple.element.comparator</code>.
      </para>

      <para>If the hash code must also be customized, the custom Comparator
        can implement the interface
        <classname>cascading.tuple.Hasher</classname>. For more information, see
        the Javadoc.
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>Cookbook</title>
    </info>

    <para>This chapter demonstrates some common idioms used in Cascading
      applications.
    </para>

    <section>
      <title>Tuples and Fields</title>

      <para>
        <variablelist>
          <varlistentry>
            <term>Copy a Tuple instance</term>

            <listitem>
              <xi:include href="cookbook-copy.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Nest a Tuple instance within a Tuple</term>

            <listitem>
              <xi:include href="cookbook-nest.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Build a longer Fields instance</term>

            <listitem>
              <xi:include href="cookbook-fieldsappend.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Remove a field from a longer Fields instance</term>

            <listitem>
              <xi:include href="cookbook-fieldssubtract.xml"/>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Stream Shaping</title>

      <para>
        <variablelist>
          <varlistentry>
            <term>Split (branch) a Tuple Stream</term>

            <listitem>
              <xi:include href="cookbook-split.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Copy a field value</term>

            <listitem>
              <xi:include href="cookbook-copyfield.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Discard (drop) a field</term>

            <listitem>
              <xi:include href="cookbook-discardfield.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Retain (keep) a field</term>

            <listitem>
              <xi:include href="cookbook-retainfield.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Rename a field</term>

            <listitem>
              <xi:include href="cookbook-renamefield.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Coerce field values from Strings to primitives</term>

            <listitem>
              <xi:include href="cookbook-coercefields.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Insert constant values into a stream</term>

            <listitem>
              <xi:include href="cookbook-insertvalue.xml"/>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Common Operations</title>

      <para>
        <variablelist>
          <varlistentry>
            <term>Parse a String date/time value</term>

            <listitem>
              <xi:include href="cookbook-parsedate.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Format a time-stamp to a date/time value</term>

            <listitem>
              <xi:include href="cookbook-formatdate.xml"/>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>

    <section>
      <title>Stream Ordering</title>

      <variablelist>
        <varlistentry>
          <term>Remove duplicate tuples in a stream</term>

          <listitem>
            <xi:include href="cookbook-distinctgroup.xml"/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Create a list of unique values</term>

          <listitem>
            <xi:include href="cookbook-distinctvalue.xml"/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Find first occurrence in time of a unique value</term>

          <listitem>
            <xi:include href="cookbook-distinctorder.xml"/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>API Usage</title>

      <para>
        <variablelist>
          <varlistentry>
            <term>Pass properties to a custom Operation</term>

            <listitem>
              <xi:include href="cookbook-passproperties.xml"/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Bind multiple sources and sinks to a Flow</term>

            <listitem>
              <xi:include href="cookbook-sourcessinks.xml"/>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </section>
  </chapter>

  <chapter>
    <info>
      <title>How It Works</title>
    </info>

    <section>
      <title xreflabel="MapReduce Job Planner" xml:id="job-planner">MapReduce
        Job Planner
      </title>

      <para>The Hadoop MapReduce Job Planner is an internal feature of
        Cascading.
      </para>

      <para>When a collection of functions, splits, and joins are all tied up
        together into a "pipe assembly", the FlowConnector object is used to
        create a new Flow instance against input and output data paths. This
        Flow is a single Cascading job.
      </para>

      <para>Internally, the FlowConnector employs an intelligent planner to
        convert the pipe assembly to a graph of dependent MapReduce jobs that
        can be executed on a Hadoop cluster.
      </para>

      <para>All this happens behind the scenes - as does the scheduling of the
        individual MapReduce jobs, and the cleanup of intermediate data sets
        that bind the jobs together.
      </para>

      <para>
        <inlinemediaobject>
          <imageobject role="fo">
            <imagedata align="center" contentwidth="5.5in"
                       fileref="images/planned-flow.svg"/>
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" contentwidth="5.5in"
                       fileref="images/planned-flow.png"/>
          </imageobject>
        </inlinemediaobject>
      </para>

      <para>The diagram above shows how a typical Flow is partitioned into
        MapReduce jobs. Every job is delimited by a temporary file that serves
        as the sink from the first job and the source for the next.
      </para>

      <para>To create a visualization of how your Flows are partitioned, call
        the
        <classname>Flow#writeDOT()</classname>
        method. This writes a
        <link
          xlink:href="http://en.wikipedia.org/wiki/DOT_language">DOT
        </link>
        file
        out to the path specified, which can be viewed in a graphics package
        like OmniGraffle or Graphviz.
      </para>
    </section>

    <section>
      <title xreflabel="Topological Scheduling" xml:id="cascade-scheduler"
             xml:lang="">The Cascade Topological Scheduler
      </title>

      <para>Cascading has a simple class,
        <classname>Cascade</classname>
        ,
        that executes a collection of Cascading Flows on a target cluster in
        dependency order.
      </para>

      <para>Consider the following example.</para>

      <itemizedlist>
        <listitem>
          <para>Flow 1 reads input file A and outputs B.</para>
        </listitem>

        <listitem>
          <para>Flow 2 expects input B and outputs C and D.</para>
        </listitem>

        <listitem>
          <para>Flow 3 expects input C and outputs E.</para>
        </listitem>
      </itemizedlist>

      <para>A
        <classname>Cascade</classname>
        is constructed through the
        <classname>CascadeConnector</classname>
        class, by building an internal
        graph that makes each Flow a "vertex", and each file an "edge". A
        topological walk on this graph will touch each vertex in order of its
        dependencies. When a vertex has all its incoming edges (i.e., files)
        available, it is scheduled on the cluster.
      </para>

      <para>In the example above, Flow 1 goes first, Flow 2 goes second, and
        Flow 3 is last.
      </para>

      <para>If two or more Flows are independent of one another, they are
        scheduled concurrently.
      </para>

      <para>And by default, if any outputs from a Flow are newer than the
        inputs, the Flow is skipped. The assumption is that the Flow was
        executed recently, since the output isn't stale. So there is no reason
        to re-execute it and use up resources or add time to the job. This is
        similar behavior a compiler would exhibit if a source file wasn't
        updated before a recompile.
      </para>

      <para>This is very handy if you have a large set of jobs, with varying
        interdependencies between them, that needs to be executed as a logical
        unit. Just pass them to the CascadeConnector and let it sort them all
        out.
      </para>
    </section>
  </chapter>
</book>
